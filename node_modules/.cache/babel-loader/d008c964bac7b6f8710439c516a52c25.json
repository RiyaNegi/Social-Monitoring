{"ast":null,"code":"import React, { memo, useCallback, useState, useMemo } from 'react';\nimport { useMotionConfig, useAnimatedPath, stackOrderPropType, stackOffsetPropType, areaCurvePropType, curveFromProp, stackOffsetFromProp, stackOrderFromProp, useTheme, useValueFormatter, withContainer, useDimensions, bindDefs, SvgWrapper, ResponsiveWrapper } from '@nivo/core';\nimport { Grid, Axes } from '@nivo/axes';\nimport { LegendPropShape, BoxLegendSvg } from '@nivo/legends';\nimport { useSpring, animated } from 'react-spring';\nimport { useTooltip, BasicTooltip, Chip, TableTooltip } from '@nivo/tooltip';\nimport PropTypes from 'prop-types';\nimport { ordinalColorsPropType, inheritedColorPropType, useOrdinalColorScale, useInheritedColor } from '@nivo/colors';\nimport { area, stack } from 'd3-shape';\nimport { scalePoint, scaleLinear } from 'd3-scale';\n\nvar StreamLayer = function StreamLayer(_ref) {\n  var layer = _ref.layer,\n      fillOpacity = _ref.fillOpacity,\n      borderWidth = _ref.borderWidth,\n      getBorderColor = _ref.getBorderColor,\n      getTooltipLabel = _ref.getTooltipLabel,\n      isInteractive = _ref.isInteractive;\n\n  var _useTooltip = useTooltip(),\n      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,\n      hideTooltip = _useTooltip.hideTooltip;\n\n  var handleMouseHover = useCallback(function (event) {\n    showTooltipFromEvent(React.createElement(BasicTooltip, {\n      id: getTooltipLabel(layer),\n      enableChip: true,\n      color: layer.color\n    }), event, 'left');\n  }, [showTooltipFromEvent, getTooltipLabel, layer]);\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var animatedPath = useAnimatedPath(layer.path);\n  var animatedProps = useSpring({\n    color: layer.color,\n    config: springConfig,\n    immediate: !animate\n  });\n  return React.createElement(animated.path, {\n    d: animatedPath,\n    fill: layer.fill ? layer.fill : animatedProps.color,\n    fillOpacity: fillOpacity,\n    stroke: getBorderColor(layer),\n    strokeWidth: borderWidth,\n    onMouseMove: isInteractive ? handleMouseHover : undefined,\n    onMouseEnter: isInteractive ? handleMouseHover : undefined,\n    onMouseLeave: isInteractive ? hideTooltip : undefined\n  });\n};\n\nvar StreamLayer$1 = memo(StreamLayer);\n\nvar StreamLayers = function StreamLayers(_ref) {\n  var layers = _ref.layers,\n      fillOpacity = _ref.fillOpacity,\n      borderWidth = _ref.borderWidth,\n      getBorderColor = _ref.getBorderColor,\n      getTooltipLabel = _ref.getTooltipLabel,\n      isInteractive = _ref.isInteractive;\n  return React.createElement(\"g\", null, layers.map(function (layer, i) {\n    return React.createElement(StreamLayer$1, {\n      key: i,\n      layer: layer,\n      getBorderColor: getBorderColor,\n      borderWidth: borderWidth,\n      fillOpacity: fillOpacity,\n      getTooltipLabel: getTooltipLabel,\n      isInteractive: isInteractive\n    });\n  }));\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar getDotY = function getDotY(datum, position) {\n  var y = datum.y2;\n\n  if (position === 'center') {\n    y = datum.y1 + (datum.y2 - datum.y1) / 2;\n  } else if (position === 'start') {\n    y = datum.y1;\n  }\n\n  return y;\n};\n\nvar StreamDots = function StreamDots(_ref) {\n  var id = _ref.id,\n      color = _ref.color,\n      data = _ref.data,\n      dotComponent = _ref.dotComponent,\n      position = _ref.position,\n      getSize = _ref.getSize,\n      getColor = _ref.getColor,\n      getBorderWidth = _ref.getBorderWidth,\n      getBorderColor = _ref.getBorderColor;\n  return data.map(function (d, i) {\n    var datum = _objectSpread2(_objectSpread2({}, d), {}, {\n      key: id,\n      color: color\n    });\n\n    return React.createElement(dotComponent, {\n      key: i,\n      datum: datum,\n      x: datum.x,\n      y: getDotY(datum, position),\n      size: getSize(datum),\n      color: getColor(datum),\n      borderWidth: getBorderWidth(datum),\n      borderColor: getBorderColor(datum)\n    });\n  });\n};\n\nvar StreamDots$1 = memo(StreamDots);\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nvar StreamSlicesItem = function StreamSlicesItem(_ref) {\n  var slice = _ref.slice,\n      height = _ref.height,\n      getTooltipLabel = _ref.getTooltipLabel,\n      getTooltipValue = _ref.getTooltipValue;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      isHover = _useState2[0],\n      setIsHover = _useState2[1];\n\n  var _useTooltip = useTooltip(),\n      showTooltipFromEvent = _useTooltip.showTooltipFromEvent,\n      hideTooltip = _useTooltip.hideTooltip;\n\n  var rows = useMemo(function () {\n    return slice.stack.map(function (p) {\n      return [React.createElement(Chip, {\n        key: p.id,\n        color: p.color\n      }), getTooltipLabel(p), getTooltipValue(p.value)];\n    });\n  }, [slice, getTooltipLabel, getTooltipValue]);\n  var handleMouseHover = useCallback(function (event) {\n    setIsHover(true);\n    showTooltipFromEvent(React.createElement(TableTooltip, {\n      rows: rows\n    }), event, 'left');\n  }, [setIsHover, showTooltipFromEvent, rows]);\n  var handleMouseLeave = useCallback(function () {\n    setIsHover(false);\n    hideTooltip();\n  }, [setIsHover, hideTooltip]);\n  return React.createElement(\"g\", {\n    transform: \"translate(\".concat(slice.x, \", 0)\")\n  }, isHover && React.createElement(\"line\", {\n    x1: 0,\n    x2: 0,\n    y1: 0,\n    y2: height,\n    stroke: \"#000\",\n    strokeOpacity: 0.35,\n    strokeWidth: 1\n  }), React.createElement(\"rect\", {\n    x: -20,\n    width: 40,\n    height: height,\n    fill: \"#000\",\n    fillOpacity: 0,\n    onMouseEnter: handleMouseHover,\n    onMouseMove: handleMouseHover,\n    onMouseLeave: handleMouseLeave\n  }));\n};\n\nvar StreamSlicesItem$1 = memo(StreamSlicesItem);\n\nvar StreamSlices = function StreamSlices(_ref) {\n  var slices = _ref.slices,\n      height = _ref.height,\n      getTooltipLabel = _ref.getTooltipLabel,\n      getTooltipValue = _ref.getTooltipValue;\n  return React.createElement(\"g\", null, slices.map(function (slice) {\n    return React.createElement(StreamSlicesItem$1, {\n      key: slice.index,\n      slice: slice,\n      height: height,\n      getTooltipLabel: getTooltipLabel,\n      getTooltipValue: getTooltipValue\n    });\n  }));\n};\n\nvar StreamSlices$1 = memo(StreamSlices);\n\nvar StreamDotsItem = function StreamDotsItem(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      size = _ref.size,\n      color = _ref.color,\n      borderWidth = _ref.borderWidth,\n      borderColor = _ref.borderColor;\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var animatedProps = useSpring({\n    x: x,\n    y: y,\n    radius: size * 0.5,\n    color: color,\n    config: springConfig,\n    immediate: !animate\n  });\n  return React.createElement(animated.circle, {\n    cx: animatedProps.x,\n    cy: animatedProps.y,\n    r: animatedProps.radius,\n    fill: animatedProps.color,\n    strokeWidth: borderWidth,\n    stroke: borderColor\n  });\n};\n\nvar StreamDotsItem$1 = memo(StreamDotsItem);\nvar StreamPropTypes = {\n  data: PropTypes.arrayOf(PropTypes.object).isRequired,\n  keys: PropTypes.array.isRequired,\n  order: stackOrderPropType.isRequired,\n  offsetType: stackOffsetPropType.isRequired,\n  curve: areaCurvePropType.isRequired,\n  axisTop: PropTypes.object,\n  axisRight: PropTypes.object,\n  axisBottom: PropTypes.object,\n  axisLeft: PropTypes.object,\n  enableGridX: PropTypes.bool.isRequired,\n  enableGridY: PropTypes.bool.isRequired,\n  colors: ordinalColorsPropType.isRequired,\n  fillOpacity: PropTypes.number.isRequired,\n  defs: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.string.isRequired\n  })).isRequired,\n  fill: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.string,\n    match: PropTypes.oneOfType([PropTypes.oneOf(['*']), PropTypes.object, PropTypes.func]).isRequired\n  })).isRequired,\n  borderWidth: PropTypes.number.isRequired,\n  borderColor: inheritedColorPropType.isRequired,\n  enableDots: PropTypes.bool.isRequired,\n  dotComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n  dotPosition: PropTypes.oneOf(['start', 'center', 'end']).isRequired,\n  dotSize: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,\n  dotColor: inheritedColorPropType.isRequired,\n  dotBorderWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,\n  dotBorderColor: inheritedColorPropType.isRequired,\n  isInteractive: PropTypes.bool,\n  tooltipLabel: PropTypes.func,\n  tooltipFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  enableStackTooltip: PropTypes.bool.isRequired,\n  legends: PropTypes.arrayOf(PropTypes.shape(LegendPropShape)).isRequired,\n  role: PropTypes.string.isRequired\n};\nvar StreamDefaultProps = {\n  order: 'none',\n  offsetType: 'wiggle',\n  curve: 'catmullRom',\n  axisBottom: {},\n  enableGridX: true,\n  enableGridY: false,\n  borderWidth: 0,\n  borderColor: {\n    from: 'color',\n    modifiers: [['darker', 1]]\n  },\n  colors: {\n    scheme: 'nivo'\n  },\n  fillOpacity: 1,\n  defs: [],\n  fill: [],\n  enableDots: false,\n  dotPosition: 'center',\n  dotComponent: StreamDotsItem$1,\n  dotSize: 6,\n  dotColor: {\n    from: 'color'\n  },\n  dotBorderWidth: 0,\n  dotBorderColor: {\n    from: 'color'\n  },\n  isInteractive: true,\n  enableStackTooltip: true,\n  legends: [],\n  role: 'img',\n  animate: true,\n  motionConfig: 'gentle'\n};\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nvar stackMin = function stackMin(layers) {\n  return Math.min.apply(Math, _toConsumableArray(layers.reduce(function (acc, layer) {\n    return [].concat(_toConsumableArray(acc), _toConsumableArray(layer.map(function (d) {\n      return d[0];\n    })));\n  }, [])));\n};\n\nvar stackMax = function stackMax(layers) {\n  return Math.max.apply(Math, _toConsumableArray(layers.reduce(function (acc, layer) {\n    return [].concat(_toConsumableArray(acc), _toConsumableArray(layer.map(function (d) {\n      return d[1];\n    })));\n  }, [])));\n};\n\nvar useStream = function useStream(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      data = _ref.data,\n      keys = _ref.keys,\n      offsetType = _ref.offsetType,\n      order = _ref.order,\n      curve = _ref.curve,\n      colors = _ref.colors,\n      borderColor = _ref.borderColor,\n      dotSize = _ref.dotSize,\n      dotColor = _ref.dotColor,\n      dotBorderWidth = _ref.dotBorderWidth,\n      dotBorderColor = _ref.dotBorderColor,\n      tooltipLabel = _ref.tooltipLabel,\n      tooltipFormat = _ref.tooltipFormat;\n  var areaGenerator = useMemo(function () {\n    return area().x(function (_ref2) {\n      var x = _ref2.x;\n      return x;\n    }).y0(function (_ref3) {\n      var y1 = _ref3.y1;\n      return y1;\n    }).y1(function (_ref4) {\n      var y2 = _ref4.y2;\n      return y2;\n    }).curve(curveFromProp(curve));\n  }, [curve]);\n  var stack$1 = useMemo(function () {\n    return stack().keys(keys).offset(stackOffsetFromProp(offsetType)).order(stackOrderFromProp(order));\n  }, [keys, offsetType, order]);\n\n  var _useMemo = useMemo(function () {\n    var layers = stack$1(data);\n    layers.forEach(function (layer) {\n      layer.forEach(function (point) {\n        point.value = point.data[layer.key];\n      });\n    });\n    var minValue = stackMin(layers);\n    var maxValue = stackMax(layers);\n    return [layers, scalePoint().domain(Array.from({\n      length: data.length\n    }, function (_, i) {\n      return i;\n    })).range([0, width]), scaleLinear().domain([minValue, maxValue]).range([height, 0])];\n  }, [stack$1, data, width, height]),\n      _useMemo2 = _slicedToArray(_useMemo, 3),\n      layers = _useMemo2[0],\n      xScale = _useMemo2[1],\n      yScale = _useMemo2[2];\n\n  var theme = useTheme();\n  var getColor = useOrdinalColorScale(colors, 'index');\n  var getBorderColor = useInheritedColor(borderColor, theme);\n  var getDotSize = useMemo(function () {\n    return typeof dotSize === 'function' ? dotSize : function () {\n      return dotSize;\n    };\n  }, [dotSize]);\n  var getDotColor = useInheritedColor(dotColor, theme);\n  var getDotBorderWidth = useMemo(function () {\n    return typeof dotBorderWidth === 'function' ? dotBorderWidth : function () {\n      return dotBorderWidth;\n    };\n  }, [dotBorderWidth]);\n  var getDotBorderColor = useInheritedColor(dotBorderColor, theme);\n  var enhancedLayers = useMemo(function () {\n    return layers.map(function (points, layerIndex) {\n      var layer = points.map(function (point, i) {\n        return {\n          index: i,\n          x: xScale(i),\n          value: point.value,\n          y1: yScale(point[0]),\n          y2: yScale(point[1])\n        };\n      });\n      return {\n        id: keys[layerIndex],\n        layer: layer,\n        path: areaGenerator(layer),\n        color: getColor({\n          index: layerIndex\n        })\n      };\n    });\n  }, [layers, keys, areaGenerator, getColor]);\n  var slices = useMemo(function () {\n    return Array.from({\n      length: data.length\n    }, function (_, i) {\n      var sliceStack = enhancedLayers.map(function (layer) {\n        return _objectSpread2({\n          id: layer.id,\n          color: layer.color\n        }, layer.layer[i]);\n      }).sort(function (a, b) {\n        return a.y2 - b.y2;\n      });\n      return {\n        index: i,\n        x: enhancedLayers[0].layer[i].x,\n        stack: sliceStack\n      };\n    });\n  }, [data.length, enhancedLayers]);\n  var getTooltipLabel = useMemo(function () {\n    if (typeof tooltipLabel === 'function') return tooltipLabel;\n    return function (d) {\n      return d.id;\n    };\n  }, [tooltipLabel]);\n  var getTooltipValue = useValueFormatter(tooltipFormat);\n  return {\n    xScale: xScale,\n    yScale: yScale,\n    layers: enhancedLayers,\n    slices: slices,\n    getBorderColor: getBorderColor,\n    getDotSize: getDotSize,\n    getDotColor: getDotColor,\n    getDotBorderWidth: getDotBorderWidth,\n    getDotBorderColor: getDotBorderColor,\n    getTooltipLabel: getTooltipLabel,\n    getTooltipValue: getTooltipValue\n  };\n};\n\nvar Stream = function Stream(_ref) {\n  var data = _ref.data,\n      keys = _ref.keys,\n      offsetType = _ref.offsetType,\n      order = _ref.order,\n      curve = _ref.curve,\n      width = _ref.width,\n      height = _ref.height,\n      partialMargin = _ref.margin,\n      axisTop = _ref.axisTop,\n      axisRight = _ref.axisRight,\n      axisBottom = _ref.axisBottom,\n      axisLeft = _ref.axisLeft,\n      enableGridX = _ref.enableGridX,\n      enableGridY = _ref.enableGridY,\n      colors = _ref.colors,\n      fillOpacity = _ref.fillOpacity,\n      borderWidth = _ref.borderWidth,\n      borderColor = _ref.borderColor,\n      defs = _ref.defs,\n      fill = _ref.fill,\n      enableDots = _ref.enableDots,\n      dotPosition = _ref.dotPosition,\n      dotComponent = _ref.dotComponent,\n      dotSize = _ref.dotSize,\n      dotColor = _ref.dotColor,\n      dotBorderWidth = _ref.dotBorderWidth,\n      dotBorderColor = _ref.dotBorderColor,\n      isInteractive = _ref.isInteractive,\n      tooltipLabel = _ref.tooltipLabel,\n      tooltipFormat = _ref.tooltipFormat,\n      enableStackTooltip = _ref.enableStackTooltip,\n      legends = _ref.legends,\n      role = _ref.role;\n\n  var _useDimensions = useDimensions(width, height, partialMargin),\n      margin = _useDimensions.margin,\n      innerWidth = _useDimensions.innerWidth,\n      innerHeight = _useDimensions.innerHeight,\n      outerWidth = _useDimensions.outerWidth,\n      outerHeight = _useDimensions.outerHeight;\n\n  var _useStream = useStream({\n    width: innerWidth,\n    height: innerHeight,\n    data: data,\n    keys: keys,\n    offsetType: offsetType,\n    order: order,\n    curve: curve,\n    colors: colors,\n    borderColor: borderColor,\n    dotSize: dotSize,\n    dotColor: dotColor,\n    dotBorderWidth: dotBorderWidth,\n    dotBorderColor: dotBorderColor,\n    tooltipLabel: tooltipLabel,\n    tooltipFormat: tooltipFormat\n  }),\n      xScale = _useStream.xScale,\n      yScale = _useStream.yScale,\n      layers = _useStream.layers,\n      slices = _useStream.slices,\n      getBorderColor = _useStream.getBorderColor,\n      getDotSize = _useStream.getDotSize,\n      getDotColor = _useStream.getDotColor,\n      getDotBorderWidth = _useStream.getDotBorderWidth,\n      getDotBorderColor = _useStream.getDotBorderColor,\n      getTooltipLabel = _useStream.getTooltipLabel,\n      getTooltipValue = _useStream.getTooltipValue;\n\n  var boundDefs = bindDefs(defs, layers, fill);\n  return React.createElement(SvgWrapper, {\n    width: outerWidth,\n    height: outerHeight,\n    margin: margin,\n    defs: boundDefs,\n    role: role\n  }, React.createElement(Grid, {\n    width: innerWidth,\n    height: innerHeight,\n    xScale: enableGridX ? xScale : null,\n    yScale: enableGridY ? yScale : null\n  }), React.createElement(StreamLayers, {\n    layers: layers,\n    fillOpacity: fillOpacity,\n    borderWidth: borderWidth,\n    getBorderColor: getBorderColor,\n    getTooltipLabel: getTooltipLabel,\n    isInteractive: isInteractive\n  }), React.createElement(Axes, {\n    xScale: xScale,\n    yScale: yScale,\n    width: innerWidth,\n    height: innerHeight,\n    top: axisTop,\n    right: axisRight,\n    bottom: axisBottom,\n    left: axisLeft\n  }), enableDots && layers.map(function (layer) {\n    return React.createElement(StreamDots$1, {\n      key: layer.id,\n      id: layer.id,\n      color: layer.color,\n      data: layer.layer,\n      dotComponent: dotComponent,\n      position: dotPosition,\n      getSize: getDotSize,\n      getColor: getDotColor,\n      getBorderWidth: getDotBorderWidth,\n      getBorderColor: getDotBorderColor\n    });\n  }), isInteractive && enableStackTooltip && React.createElement(StreamSlices$1, {\n    slices: slices,\n    height: innerHeight,\n    getTooltipValue: getTooltipValue,\n    getTooltipLabel: getTooltipLabel\n  }), legends.map(function (legend, i) {\n    var legendData = layers.map(function (l) {\n      return {\n        id: l.id,\n        label: l.id,\n        color: l.color,\n        fill: l.fill\n      };\n    }).reverse();\n    return React.createElement(BoxLegendSvg, Object.assign({\n      key: i\n    }, legend, {\n      containerWidth: innerWidth,\n      containerHeight: innerHeight,\n      data: legendData\n    }));\n  }));\n};\n\nvar WrappedStream = withContainer(Stream);\nWrappedStream.defaultProps = StreamDefaultProps;\n\nvar ResponsiveStream = function ResponsiveStream(props) {\n  return React.createElement(ResponsiveWrapper, null, function (_ref) {\n    var width = _ref.width,\n        height = _ref.height;\n    return React.createElement(WrappedStream, Object.assign({\n      width: width,\n      height: height\n    }, props));\n  });\n};\n\nexport { ResponsiveStream, WrappedStream as Stream, StreamDefaultProps, StreamPropTypes };","map":{"version":3,"sources":["../src/StreamLayer.js","../src/StreamLayers.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../src/StreamDots.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../src/StreamSlicesItem.js","../src/StreamSlices.js","../src/StreamDotsItem.js","../src/props.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../src/hooks.js","../src/Stream.js","../src/ResponsiveStream.js"],"names":["StreamLayer","layer","fillOpacity","borderWidth","getBorderColor","getTooltipLabel","isInteractive","showTooltipFromEvent","hideTooltip","useTooltip","handleMouseHover","useCallback","color","animate","springConfig","useMotionConfig","animatedPath","useAnimatedPath","animatedProps","useSpring","config","immediate","undefined","memo","StreamLayers","layers","defineProperty","getDotY","y","datum","position","StreamDots","id","data","dotComponent","getSize","getColor","getBorderWidth","key","x","size","borderColor","arrayLikeToArray","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","StreamSlicesItem","slice","height","getTooltipValue","isHover","setIsHover","useState","rows","useMemo","p","handleMouseLeave","StreamSlices","slices","StreamDotsItem","radius","StreamPropTypes","PropTypes","keys","order","stackOrderPropType","offsetType","stackOffsetPropType","curve","areaCurvePropType","axisTop","axisRight","axisBottom","axisLeft","enableGridX","enableGridY","colors","ordinalColorsPropType","defs","isRequired","fill","match","inheritedColorPropType","enableDots","dotPosition","dotSize","dotColor","dotBorderWidth","dotBorderColor","tooltipLabel","tooltipFormat","enableStackTooltip","legends","role","StreamDefaultProps","from","modifiers","scheme","motionConfig","arrayWithoutHoles","iterableToArray","nonIterableSpread","stackMin","Math","d","stackMax","useStream","width","areaGenerator","y1","y2","curveFromProp","stack","d3Stack","stackOffsetFromProp","stackOrderFromProp","xScale","yScale","point","minValue","maxValue","length","scaleLinear","theme","useTheme","useOrdinalColorScale","useInheritedColor","getDotSize","getDotColor","getDotBorderWidth","getDotBorderColor","enhancedLayers","index","value","path","layerIndex","sliceStack","a","b","useValueFormatter","Stream","margin","partialMargin","innerWidth","innerHeight","outerWidth","outerHeight","useDimensions","boundDefs","bindDefs","legendData","l","label","i","WrappedStream","withContainer","ResponsiveStream"],"mappings":";;;;;;;;;;;AAcA,IAAMA,WAAW,GAAG,SAAdA,WAAc,CAAA,IAAA,EAOd;AAAA,MANFC,KAME,GAAA,IAAA,CANFA,KAME;AAAA,MALFC,WAKE,GAAA,IAAA,CALFA,WAKE;AAAA,MAJFC,WAIE,GAAA,IAAA,CAJFA,WAIE;AAAA,MAHFC,cAGE,GAAA,IAAA,CAHFA,cAGE;AAAA,MAFFC,eAEE,GAAA,IAAA,CAFFA,eAEE;AAAA,MADFC,aACE,GAAA,IAAA,CADFA,aACE;;AAAA,MAAA,WAAA,GAC4CG,UAD5C,EAAA;AAAA,MACMF,oBADN,GAAA,WAAA,CAAA,oBAAA;AAAA,MAC4BC,WAD5B,GAAA,WAAA,CAAA,WAAA;;AAEF,MAAME,gBAAgB,GAAGC,WAAW,CAChC,UAAA,KAAA,EAAS;AACLJ,IAAAA,oBAAoB,CAChB,KAAA,CAAA,aAAA,CAAA,YAAA,EAAA;AAAc,MAAA,EAAE,EAAEF,eAAe,CAAjC,KAAiC,CAAjC;AAA0C,MAAA,UAAU,EAApD,IAAA;AAA4D,MAAA,KAAK,EAAEJ,KAAK,CAACW;AAAzE,KAAA,CADgB,EAAA,KAAA,EAApBL,MAAoB,CAApBA;AAF4B,GAAA,EAQhC,CAAA,oBAAA,EAAA,eAAA,EARJ,KAQI,CARgC,CAApC;;AAFE,MAAA,gBAAA,GAawCQ,eAbxC,EAAA;AAAA,MAaMF,OAbN,GAAA,gBAAA,CAAA,OAAA;AAAA,MAauBC,YAbvB,GAAA,gBAAA,CAAA,MAAA;;AAcF,MAAME,YAAY,GAAGC,eAAe,CAAChB,KAAK,CAA1C,IAAoC,CAApC;AACA,MAAMiB,aAAa,GAAGC,SAAS,CAAC;AAC5BP,IAAAA,KAAK,EAAEX,KAAK,CADgB,KAAA;AAE5BmB,IAAAA,MAAM,EAFsB,YAAA;AAG5BC,IAAAA,SAAS,EAAE,CAACR;AAHgB,GAAD,CAA/B;AAMA,SACI,KAAA,CAAA,aAAA,CAAC,QAAD,CAAA,IAAA,EAAA;AACI,IAAA,CAAC,EADL,YAAA;AAEI,IAAA,IAAI,EAAEZ,KAAK,CAALA,IAAAA,GAAaA,KAAK,CAAlBA,IAAAA,GAA0BiB,aAAa,CAFjD,KAAA;AAGI,IAAA,WAAW,EAHf,WAAA;AAII,IAAA,MAAM,EAAEd,cAAc,CAJ1B,KAI0B,CAJ1B;AAKI,IAAA,WAAW,EALf,WAAA;AAMI,IAAA,WAAW,EAAEE,aAAa,GAAA,gBAAA,GAN9B,SAAA;AAOI,IAAA,YAAY,EAAEA,aAAa,GAAA,gBAAA,GAP/B,SAAA;AAQI,IAAA,YAAY,EAAEA,aAAa,GAAA,WAAA,GAAiBgB;AARhD,GAAA,CADJ;AA5BJ,CAAA;;AAmDA,IAAA,aAAA,GAAeC,IAAI,CAAnB,WAAmB,CAAnB;;ACrDA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAAA,IAAA,EAOf;AAAA,MANFC,MAME,GAAA,IAAA,CANFA,MAME;AAAA,MALFvB,WAKE,GAAA,IAAA,CALFA,WAKE;AAAA,MAJFC,WAIE,GAAA,IAAA,CAJFA,WAIE;AAAA,MAHFC,cAGE,GAAA,IAAA,CAHFA,cAGE;AAAA,MAFFC,eAEE,GAAA,IAAA,CAFFA,eAEE;AAAA,MADFC,aACE,GAAA,IAAA,CADFA,aACE;AACF,SACI,KAAA,CAAA,aAAA,CAAA,GAAA,EAAA,IAAA,EACK,MAAM,CAAN,GAAA,CAAW,UAAA,KAAA,EAAA,CAAA,EAAA;AAAA,WACR,KAAA,CAAA,aAAA,CAAA,aAAA,EAAA;AACI,MAAA,GAAG,EADP,CAAA;AAEI,MAAA,KAAK,EAFT,KAAA;AAGI,MAAA,cAAc,EAHlB,cAAA;AAII,MAAA,WAAW,EAJf,WAAA;AAKI,MAAA,WAAW,EALf,WAAA;AAMI,MAAA,eAAe,EANnB,eAAA;AAOI,MAAA,aAAa,EAAEA;AAPnB,KAAA,CADQ;AAFpB,GAES,CADL,CADJ;AARJ,CAAA;;ACZe,SAAS,eAAT,CAAyB,GAAzB,EAA8B,GAA9B,EAAmC,KAAnC,EAA0C;AACvD,MAAI,GAAG,IAAI,GAAX,EAAgB;AACd,IAAA,MAAM,CAAC,cAAP,CAAsB,GAAtB,EAA2B,GAA3B,EAAgC;AAC9B,MAAA,KAAK,EAAE,KADuB;AAE9B,MAAA,UAAU,EAAE,IAFkB;AAG9B,MAAA,YAAY,EAAE,IAHgB;AAI9B,MAAA,QAAQ,EAAE;AAJoB,KAAhC;AAMD,GAPD,MAOO;AACL,IAAA,GAAG,CAAC,GAAD,CAAH,GAAW,KAAX;AACD;;AAED,SAAO,GAAP;AACF;;ACXA,SAAS,OAAT,CAAiB,MAAjB,EAAyB,cAAzB,EAAyC;AACvC,MAAI,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,MAAZ,CAAX;;AAEA,MAAI,MAAM,CAAC,qBAAX,EAAkC;AAChC,QAAI,OAAO,GAAG,MAAM,CAAC,qBAAP,CAA6B,MAA7B,CAAd;AACA,QAAI,cAAJ,EAAoB,OAAO,GAAG,OAAO,CAAC,MAAR,CAAe,UAAU,GAAV,EAAe;AAC1D,aAAO,MAAM,CAAC,wBAAP,CAAgC,MAAhC,EAAwC,GAAxC,EAA6C,UAApD;AACD,KAF6B,CAAV;AAGpB,IAAA,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,IAAhB,EAAsB,OAAtB;AACD;;AAED,SAAO,IAAP;AACD;;AAEc,SAAS,cAAT,CAAwB,MAAxB,EAAgC;AAC7C,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,QAAI,MAAM,GAAG,SAAS,CAAC,CAAD,CAAT,IAAgB,IAAhB,GAAuB,SAAS,CAAC,CAAD,CAAhC,GAAsC,EAAnD;;AAEA,QAAI,CAAC,GAAG,CAAR,EAAW;AACT,MAAA,OAAO,CAAC,MAAM,CAAC,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8B,OAA9B,CAAsC,UAAU,GAAV,EAAe;AACnDoB,QAAAA,eAAc,CAAC,MAAD,EAAS,GAAT,EAAc,MAAM,CAAC,GAAD,CAApB,CAAdA;AACD,OAFD;AAGD,KAJD,MAIO,IAAI,MAAM,CAAC,yBAAX,EAAsC;AAC3C,MAAA,MAAM,CAAC,gBAAP,CAAwB,MAAxB,EAAgC,MAAM,CAAC,yBAAP,CAAiC,MAAjC,CAAhC;AACD,KAFM,MAEA;AACL,MAAA,OAAO,CAAC,MAAM,CAAC,MAAD,CAAP,CAAP,CAAwB,OAAxB,CAAgC,UAAU,GAAV,EAAe;AAC7C,QAAA,MAAM,CAAC,cAAP,CAAsB,MAAtB,EAA8B,GAA9B,EAAmC,MAAM,CAAC,wBAAP,CAAgC,MAAhC,EAAwC,GAAxC,CAAnC;AACD,OAFD;AAGD;AACF;;AAED,SAAO,MAAP;AACF;;ACvBA,IAAMC,OAAO,GAAG,SAAVA,OAAU,CAAA,KAAA,EAAA,QAAA,EAAqB;AACjC,MAAIC,CAAC,GAAGC,KAAK,CAAb,EAAA;;AACA,MAAIC,QAAQ,KAAZ,QAAA,EAA2B;AACvBF,IAAAA,CAAC,GAAGC,KAAK,CAALA,EAAAA,GAAW,CAACA,KAAK,CAALA,EAAAA,GAAWA,KAAK,CAAjB,EAAA,IAAfD,CAAAA;AADJ,GAAA,MAEO,IAAIE,QAAQ,KAAZ,OAAA,EAA0B;AAC7BF,IAAAA,CAAC,GAAGC,KAAK,CAATD,EAAAA;AACH;;AAED,SAAA,CAAA;AARJ,CAAA;;AAWA,IAAMG,UAAU,GAAG,SAAbA,UAAa,CAAA,IAAA,EAUb;AAAA,MATFC,EASE,GAAA,IAAA,CATFA,EASE;AAAA,MARFpB,KAQE,GAAA,IAAA,CARFA,KAQE;AAAA,MAPFqB,IAOE,GAAA,IAAA,CAPFA,IAOE;AAAA,MANFC,YAME,GAAA,IAAA,CANFA,YAME;AAAA,MALFJ,QAKE,GAAA,IAAA,CALFA,QAKE;AAAA,MAJFK,OAIE,GAAA,IAAA,CAJFA,OAIE;AAAA,MAHFC,QAGE,GAAA,IAAA,CAHFA,QAGE;AAAA,MAFFC,cAEE,GAAA,IAAA,CAFFA,cAEE;AAAA,MADFjC,cACE,GAAA,IAAA,CADFA,cACE;AACF,SAAO,IAAI,CAAJ,GAAA,CAAS,UAAA,CAAA,EAAA,CAAA,EAAU;AACtB,QAAMyB,KAAK,GAAA,cAAA,CAAA,cAAA,CAAA,EAAA,EAAA,CAAA,CAAA,EAAA,EAAA,EAAA;AAAWS,MAAAA,GAAG,EAAd,EAAA;AAAoB1B,MAAAA,KAAK,EAALA;AAApB,KAAA,CAAX;;AAEA,WAAO,KAAK,CAAL,aAAA,CAAA,YAAA,EAAkC;AACrC0B,MAAAA,GAAG,EADkC,CAAA;AAErCT,MAAAA,KAAK,EAFgC,KAAA;AAGrCU,MAAAA,CAAC,EAAEV,KAAK,CAH6B,CAAA;AAIrCD,MAAAA,CAAC,EAAED,OAAO,CAAA,KAAA,EAJ2B,QAI3B,CAJ2B;AAKrCa,MAAAA,IAAI,EAAEL,OAAO,CALwB,KAKxB,CALwB;AAMrCvB,MAAAA,KAAK,EAAEwB,QAAQ,CANsB,KAMtB,CANsB;AAOrCjC,MAAAA,WAAW,EAAEkC,cAAc,CAPU,KAOV,CAPU;AAQrCI,MAAAA,WAAW,EAAErC,cAAc,CAAA,KAAA;AARU,KAAlC,CAAP;AAHJ,GAAO,CAAP;AAXJ,CAAA;;AA6CA,IAAA,YAAA,GAAemB,IAAI,CAAnB,UAAmB,CAAnB;;ACnEe,SAAS,eAAT,CAAyB,GAAzB,EAA8B;AAC3C,MAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB,OAAO,GAAP;AAC1B;;ACFe,SAAS,qBAAT,CAA+B,GAA/B,EAAoC,CAApC,EAAuC;AACpD,MAAI,OAAO,MAAP,KAAkB,WAAlB,IAAiC,EAAE,MAAM,CAAC,QAAP,IAAmB,MAAM,CAAC,GAAD,CAA3B,CAArC,EAAwE;AACxE,MAAI,IAAI,GAAG,EAAX;AACA,MAAI,EAAE,GAAG,IAAT;AACA,MAAI,EAAE,GAAG,KAAT;AACA,MAAI,EAAE,GAAG,SAAT;;AAEA,MAAI;AACF,SAAK,IAAI,EAAE,GAAG,GAAG,CAAC,MAAM,CAAC,QAAR,CAAH,EAAT,EAAiC,EAAtC,EAA0C,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC,IAAH,EAAN,EAAiB,IAAxB,CAA1C,EAAyE,EAAE,GAAG,IAA9E,EAAoF;AAClF,MAAA,IAAI,CAAC,IAAL,CAAU,EAAE,CAAC,KAAb;;AAEA,UAAI,CAAC,IAAI,IAAI,CAAC,MAAL,KAAgB,CAAzB,EAA4B;AAC7B;AACF,GAND,CAME,OAAO,GAAP,EAAY;AACZ,IAAA,EAAE,GAAG,IAAL;AACA,IAAA,EAAE,GAAG,GAAL;AACD,GATD,SASU;AACR,QAAI;AACF,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,QAAD,CAAF,IAAgB,IAA3B,EAAiC,EAAE,CAAC,QAAD,CAAF;AAClC,KAFD,SAEU;AACR,UAAI,EAAJ,EAAQ,MAAM,EAAN;AACT;AACF;;AAED,SAAO,IAAP;AACF;;ACzBe,SAAS,iBAAT,CAA2B,GAA3B,EAAgC,GAAhC,EAAqC;AAClD,MAAI,GAAG,IAAI,IAAP,IAAe,GAAG,GAAG,GAAG,CAAC,MAA7B,EAAqC,GAAG,GAAG,GAAG,CAAC,MAAV;;AAErC,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,IAAI,GAAG,IAAI,KAAJ,CAAU,GAAV,CAAvB,EAAuC,CAAC,GAAG,GAA3C,EAAgD,CAAC,EAAjD,EAAqD;AACnD,IAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAG,CAAC,CAAD,CAAb;AACD;;AAED,SAAO,IAAP;AACF;;ACPe,SAAS,2BAAT,CAAqC,CAArC,EAAwC,MAAxC,EAAgD;AAC7D,MAAI,CAAC,CAAL,EAAQ;AACR,MAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B,OAAOmB,iBAAgB,CAAC,CAAD,EAAI,MAAJ,CAAvB;AAC3B,MAAI,CAAC,GAAG,MAAM,CAAC,SAAP,CAAiB,QAAjB,CAA0B,IAA1B,CAA+B,CAA/B,EAAkC,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;AACA,MAAI,CAAC,KAAK,QAAN,IAAkB,CAAC,CAAC,WAAxB,EAAqC,CAAC,GAAG,CAAC,CAAC,WAAF,CAAc,IAAlB;AACrC,MAAI,CAAC,KAAK,KAAN,IAAe,CAAC,KAAK,KAAzB,EAAgC,OAAO,KAAK,CAAC,IAAN,CAAW,CAAX,CAAP;AAChC,MAAI,CAAC,KAAK,WAAN,IAAqB,2CAA2C,IAA3C,CAAgD,CAAhD,CAAzB,EAA6E,OAAOA,iBAAgB,CAAC,CAAD,EAAI,MAAJ,CAAvB;AAC/E;;ACRe,SAAS,gBAAT,GAA4B;AACzC,QAAM,IAAI,SAAJ,CAAc,2IAAd,CAAN;AACF;;ACEe,SAAS,cAAT,CAAwB,GAAxB,EAA6B,CAA7B,EAAgC;AAC7C,SAAOC,eAAc,CAAC,GAAD,CAAdA,IAAuBC,qBAAoB,CAAC,GAAD,EAAM,CAAN,CAA3CD,IAAuDE,2BAA0B,CAAC,GAAD,EAAM,CAAN,CAAjFF,IAA6FG,gBAAe,EAAnH;AACF;;ACOA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAA,IAAA,EAAyD;AAAA,MAAtDC,KAAsD,GAAA,IAAA,CAAtDA,KAAsD;AAAA,MAA/CC,MAA+C,GAAA,IAAA,CAA/CA,MAA+C;AAAA,MAAvC5C,eAAuC,GAAA,IAAA,CAAvCA,eAAuC;AAAA,MAAtB6C,eAAsB,GAAA,IAAA,CAAtBA,eAAsB;;AAAA,MAAA,SAAA,GAChDG,QAAQ,CADwC,KACxC,CADwC;AAAA,MAAA,UAAA,GAAA,cAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAA,MACvEF,OADuE,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAC9DC,UAD8D,GAAA,UAAA,CAAA,CAAA,CAAA;;AAAA,MAAA,WAAA,GAEhC3C,UAFgC,EAAA;AAAA,MAEtEF,oBAFsE,GAAA,WAAA,CAAA,oBAAA;AAAA,MAEhDC,WAFgD,GAAA,WAAA,CAAA,WAAA;;AAI9E,MAAM8C,IAAI,GAAGC,OAAO,CAChB,YAAA;AAAA,WACI,KAAK,CAAL,KAAA,CAAA,GAAA,CAAgB,UAAA,CAAA,EAAC;AAAA,aAAI,CACjB,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AAAM,QAAA,GAAG,EAAEC,CAAC,CAAZ,EAAA;AAAiB,QAAA,KAAK,EAAEA,CAAC,CAAC5C;AAA1B,OAAA,CADiB,EAEjBP,eAAe,CAFE,CAEF,CAFE,EAGjB6C,eAAe,CAACM,CAAC,CAHJ,KAGE,CAHE,CAAJ;AADrB,KACI,CADJ;AADgB,GAAA,EAOhB,CAAA,KAAA,EAAA,eAAA,EAPJ,eAOI,CAPgB,CAApB;AAUA,MAAM9C,gBAAgB,GAAGC,WAAW,CAChC,UAAA,KAAA,EAAS;AACLyC,IAAAA,UAAU,CAAVA,IAAU,CAAVA;AACA7C,IAAAA,oBAAoB,CAAC,KAAA,CAAA,aAAA,CAAA,YAAA,EAAA;AAAc,MAAA,IAAI,EAAE+C;AAApB,KAAA,CAAD,EAAA,KAAA,EAApB/C,MAAoB,CAApBA;AAH4B,GAAA,EAKhC,CAAA,UAAA,EAAA,oBAAA,EALJ,IAKI,CALgC,CAApC;AAQA,MAAMkD,gBAAgB,GAAG9C,WAAW,CAAC,YAAM;AACvCyC,IAAAA,UAAU,CAAVA,KAAU,CAAVA;AACA5C,IAAAA,WAAW;AAFqB,GAAA,EAGjC,CAAA,UAAA,EAHH,WAGG,CAHiC,CAApC;AAKA,SACI,KAAA,CAAA,aAAA,CAAA,GAAA,EAAA;AAAG,IAAA,SAAS,EAAA,aAAA,MAAA,CAAewC,KAAK,CAApB,CAAA,EAAA,MAAA;AAAZ,GAAA,EACKG,OAAO,IACJ,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;AACI,IAAA,EAAE,EADN,CAAA;AAEI,IAAA,EAAE,EAFN,CAAA;AAGI,IAAA,EAAE,EAHN,CAAA;AAII,IAAA,EAAE,EAJN,MAAA;AAKI,IAAA,MAAM,EALV,MAAA;AAMI,IAAA,aAAa,EANjB,IAAA;AAOI,IAAA,WAAW,EAAE;AAPjB,GAAA,CAFR,EAYI,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;AACI,IAAA,CAAC,EAAE,CADP,EAAA;AAEI,IAAA,KAAK,EAFT,EAAA;AAGI,IAAA,MAAM,EAHV,MAAA;AAII,IAAA,IAAI,EAJR,MAAA;AAKI,IAAA,WAAW,EALf,CAAA;AAMI,IAAA,YAAY,EANhB,gBAAA;AAOI,IAAA,WAAW,EAPf,gBAAA;AAQI,IAAA,YAAY,EAAEM;AARlB,GAAA,CAZJ,CADJ;AA3BJ,CAAA;;AA6DA,IAAA,kBAAA,GAAelC,IAAI,CAAnB,gBAAmB,CAAnB;;AC9DA,IAAMmC,YAAY,GAAG,SAAfA,YAAe,CAAA,IAAA,EAAA;AAAA,MAAGC,MAAH,GAAA,IAAA,CAAA,MAAA;AAAA,MAAWV,MAAX,GAAA,IAAA,CAAA,MAAA;AAAA,MAAmB5C,eAAnB,GAAA,IAAA,CAAA,eAAA;AAAA,MAAoC6C,eAApC,GAAA,IAAA,CAAA,eAAA;AAAA,SACjB,KAAA,CAAA,aAAA,CAAA,GAAA,EAAA,IAAA,EACK,MAAM,CAAN,GAAA,CAAW,UAAA,KAAA,EAAK;AAAA,WACb,KAAA,CAAA,aAAA,CAAA,kBAAA,EAAA;AACI,MAAA,GAAG,EAAEF,KAAK,CADd,KAAA;AAEI,MAAA,KAAK,EAFT,KAAA;AAGI,MAAA,MAAM,EAHV,MAAA;AAII,MAAA,eAAe,EAJnB,eAAA;AAKI,MAAA,eAAe,EAAEE;AALrB,KAAA,CADa;AAFJ,GAEZ,CADL,CADiB;AAArB,CAAA;;AAiCA,IAAA,cAAA,GAAe3B,IAAI,CAAnB,YAAmB,CAAnB;;AChCA,IAAMqC,cAAc,GAAG,SAAjBA,cAAiB,CAAA,IAAA,EAAqD;AAAA,MAAlDrB,CAAkD,GAAA,IAAA,CAAlDA,CAAkD;AAAA,MAA/CX,CAA+C,GAAA,IAAA,CAA/CA,CAA+C;AAAA,MAA5CY,IAA4C,GAAA,IAAA,CAA5CA,IAA4C;AAAA,MAAtC5B,KAAsC,GAAA,IAAA,CAAtCA,KAAsC;AAAA,MAA/BT,WAA+B,GAAA,IAAA,CAA/BA,WAA+B;AAAA,MAAlBsC,WAAkB,GAAA,IAAA,CAAlBA,WAAkB;;AAAA,MAAA,gBAAA,GAC9B1B,eAD8B,EAAA;AAAA,MAChEF,OADgE,GAAA,gBAAA,CAAA,OAAA;AAAA,MAC/CC,YAD+C,GAAA,gBAAA,CAAA,MAAA;;AAExE,MAAMI,aAAa,GAAGC,SAAS,CAAC;AAC5BoB,IAAAA,CAAC,EAD2B,CAAA;AAE5BX,IAAAA,CAAC,EAF2B,CAAA;AAG5BiC,IAAAA,MAAM,EAAErB,IAAI,GAHgB,GAAA;AAI5B5B,IAAAA,KAAK,EAJuB,KAAA;AAK5BQ,IAAAA,MAAM,EALsB,YAAA;AAM5BC,IAAAA,SAAS,EAAE,CAACR;AANgB,GAAD,CAA/B;AASA,SACI,KAAA,CAAA,aAAA,CAAC,QAAD,CAAA,MAAA,EAAA;AACI,IAAA,EAAE,EAAEK,aAAa,CADrB,CAAA;AAEI,IAAA,EAAE,EAAEA,aAAa,CAFrB,CAAA;AAGI,IAAA,CAAC,EAAEA,aAAa,CAHpB,MAAA;AAII,IAAA,IAAI,EAAEA,aAAa,CAJvB,KAAA;AAKI,IAAA,WAAW,EALf,WAAA;AAMI,IAAA,MAAM,EAAEuB;AANZ,GAAA,CADJ;AAXJ,CAAA;;AAgCA,IAAA,gBAAA,GAAelB,IAAI,CAAnB,cAAmB,CAAnB;IC/BauC,eAAe,GAAG;AAC3B7B,EAAAA,IAAI,EAAE8B,SAAS,CAATA,OAAAA,CAAkBA,SAAS,CAA3BA,MAAAA,EADqB,UAAA;AAE3BC,EAAAA,IAAI,EAAED,SAAS,CAATA,KAAAA,CAFqB,UAAA;AAG3BE,EAAAA,KAAK,EAAEC,kBAAkB,CAHE,UAAA;AAI3BC,EAAAA,UAAU,EAAEC,mBAAmB,CAJJ,UAAA;AAK3BC,EAAAA,KAAK,EAAEC,iBAAiB,CALG,UAAA;AAO3BC,EAAAA,OAAO,EAAER,SAAS,CAPS,MAAA;AAQ3BS,EAAAA,SAAS,EAAET,SAAS,CARO,MAAA;AAS3BU,EAAAA,UAAU,EAAEV,SAAS,CATM,MAAA;AAU3BW,EAAAA,QAAQ,EAAEX,SAAS,CAVQ,MAAA;AAW3BY,EAAAA,WAAW,EAAEZ,SAAS,CAATA,IAAAA,CAXc,UAAA;AAY3Ba,EAAAA,WAAW,EAAEb,SAAS,CAATA,IAAAA,CAZc,UAAA;AAc3Bc,EAAAA,MAAM,EAAEC,qBAAqB,CAdF,UAAA;AAe3B5E,EAAAA,WAAW,EAAE6D,SAAS,CAATA,MAAAA,CAfc,UAAA;AAgB3BgB,EAAAA,IAAI,EAAE,SAAS,CAAT,OAAA,CACF,SAAS,CAAT,KAAA,CAAgB;AACZ/C,IAAAA,EAAE,EAAE+B,SAAS,CAATA,MAAAA,CAAiBiB;AADT,GAAhB,CADE,EAhBqB,UAAA;AAqB3BC,EAAAA,IAAI,EAAE,SAAS,CAAT,OAAA,CACF,SAAS,CAAT,KAAA,CAAgB;AACZjD,IAAAA,EAAE,EAAE+B,SAAS,CADD,MAAA;AAEZmB,IAAAA,KAAK,EAAEnB,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAATA,KAAAA,CAAgB,CAAjB,GAAiB,CAAhBA,CAAD,EAAyBA,SAAS,CAAlC,MAAA,EAA2CA,SAAS,CAAxEA,IAAoB,CAApBA,EACFiB;AAHO,GAAhB,CADE,EArBqB,UAAA;AA4B3B7E,EAAAA,WAAW,EAAE4D,SAAS,CAATA,MAAAA,CA5Bc,UAAA;AA6B3BtB,EAAAA,WAAW,EAAE0C,sBAAsB,CA7BR,UAAA;AA+B3BC,EAAAA,UAAU,EAAErB,SAAS,CAATA,IAAAA,CA/Be,UAAA;AAgC3B7B,EAAAA,YAAY,EAAE6B,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAAV,IAAA,EAAiBA,SAAS,CAA9CA,MAAoB,CAApBA,EAhCa,UAAA;AAiC3BsB,EAAAA,WAAW,EAAEtB,SAAS,CAATA,KAAAA,CAAgB,CAAA,OAAA,EAAA,QAAA,EAAhBA,KAAgB,CAAhBA,EAjCc,UAAA;AAkC3BuB,EAAAA,OAAO,EAAEvB,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAAV,MAAA,EAAmBA,SAAS,CAAhDA,IAAoB,CAApBA,EAlCkB,UAAA;AAmC3BwB,EAAAA,QAAQ,EAAEJ,sBAAsB,CAnCL,UAAA;AAoC3BK,EAAAA,cAAc,EAAEzB,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAAV,MAAA,EAAmBA,SAAS,CAAhDA,IAAoB,CAApBA,EApCW,UAAA;AAqC3B0B,EAAAA,cAAc,EAAEN,sBAAsB,CArCX,UAAA;AAuC3B7E,EAAAA,aAAa,EAAEyD,SAAS,CAvCG,IAAA;AAwC3B2B,EAAAA,YAAY,EAAE3B,SAAS,CAxCI,IAAA;AAyC3B4B,EAAAA,aAAa,EAAE5B,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAAV,IAAA,EAAiBA,SAAS,CAzClC,MAyCQ,CAApBA,CAzCY;AA0C3B6B,EAAAA,kBAAkB,EAAE7B,SAAS,CAATA,IAAAA,CA1CO,UAAA;AA4C3B8B,EAAAA,OAAO,EAAE9B,SAAS,CAATA,OAAAA,CAAkBA,SAAS,CAATA,KAAAA,CAAlBA,eAAkBA,CAAlBA,EA5CkB,UAAA;AA6C3B+B,EAAAA,IAAI,EAAE/B,SAAS,CAATA,MAAAA,CAAiBiB;AA7CI,C;IAgDlBe,kBAAkB,GAAG;AAC9B9B,EAAAA,KAAK,EADyB,MAAA;AAE9BE,EAAAA,UAAU,EAFoB,QAAA;AAG9BE,EAAAA,KAAK,EAHyB,YAAA;AAK9BI,EAAAA,UAAU,EALoB,EAAA;AAM9BE,EAAAA,WAAW,EANmB,IAAA;AAO9BC,EAAAA,WAAW,EAPmB,KAAA;AAS9BzE,EAAAA,WAAW,EATmB,CAAA;AAU9BsC,EAAAA,WAAW,EAAE;AAAEuD,IAAAA,IAAI,EAAN,OAAA;AAAiBC,IAAAA,SAAS,EAAE,CAAC,CAAA,QAAA,EAAD,CAAC,CAAD;AAA5B,GAViB;AAY9BpB,EAAAA,MAAM,EAAE;AAAEqB,IAAAA,MAAM,EAAE;AAAV,GAZsB;AAa9BhG,EAAAA,WAAW,EAbmB,CAAA;AAc9B6E,EAAAA,IAAI,EAd0B,EAAA;AAe9BE,EAAAA,IAAI,EAf0B,EAAA;AAiB9BG,EAAAA,UAAU,EAjBoB,KAAA;AAkB9BC,EAAAA,WAAW,EAlBmB,QAAA;AAmB9BnD,EAAAA,YAAY,EAnBkB,gBAAA;AAoB9BoD,EAAAA,OAAO,EApBuB,CAAA;AAqB9BC,EAAAA,QAAQ,EAAE;AAAES,IAAAA,IAAI,EAAE;AAAR,GArBoB;AAsB9BR,EAAAA,cAAc,EAtBgB,CAAA;AAuB9BC,EAAAA,cAAc,EAAE;AAAEO,IAAAA,IAAI,EAAE;AAAR,GAvBc;AAyB9B1F,EAAAA,aAAa,EAzBiB,IAAA;AA2B9BsF,EAAAA,kBAAkB,EA3BY,IAAA;AA6B9BC,EAAAA,OAAO,EA7BuB,EAAA;AA8B9BC,EAAAA,IAAI,EA9B0B,KAAA;AAgC9BjF,EAAAA,OAAO,EAhCuB,IAAA;AAiC9BsF,EAAAA,YAAY,EAAE;AAjCgB,C;;AC7DnB,SAAS,kBAAT,CAA4B,GAA5B,EAAiC;AAC9C,MAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB,OAAOzD,iBAAgB,CAAC,GAAD,CAAvB;AAC1B;;ACHe,SAAS,gBAAT,CAA0B,IAA1B,EAAgC;AAC7C,MAAI,OAAO,MAAP,KAAkB,WAAlB,IAAiC,MAAM,CAAC,QAAP,IAAmB,MAAM,CAAC,IAAD,CAA9D,EAAsE,OAAO,KAAK,CAAC,IAAN,CAAW,IAAX,CAAP;AACxE;;ACFe,SAAS,kBAAT,GAA8B;AAC3C,QAAM,IAAI,SAAJ,CAAc,sIAAd,CAAN;AACF;;ACEe,SAAS,kBAAT,CAA4B,GAA5B,EAAiC;AAC9C,SAAO0D,kBAAiB,CAAC,GAAD,CAAjBA,IAA0BC,gBAAe,CAAC,GAAD,CAAzCD,IAAkDvD,2BAA0B,CAAC,GAAD,CAA5EuD,IAAqFE,kBAAiB,EAA7G;AACF;;ACMA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAA,MAAA,EAAM;AAAA,SACnBC,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAI,kBAAA,CAAQ,MAAM,CAAN,MAAA,CAAc,UAAA,GAAA,EAAA,KAAA,EAAA;AAAA,WAAA,GAAA,MAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,EAAA,kBAAA,CAA4B,KAAK,CAAL,GAAA,CAAU,UAAA,CAAA,EAAC;AAAA,aAAIC,CAAC,CAAL,CAAK,CAAL;AAAvC,KAA4B,CAA5B,CAAA,CAAA;AAAd,GAAA,EADO,EACP,CAAR,CAAJD,CADmB;AAAvB,CAAA;;AAEA,IAAME,QAAQ,GAAG,SAAXA,QAAW,CAAA,MAAA,EAAM;AAAA,SACnBF,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAI,kBAAA,CAAQ,MAAM,CAAN,MAAA,CAAc,UAAA,GAAA,EAAA,KAAA,EAAA;AAAA,WAAA,GAAA,MAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,EAAA,kBAAA,CAA4B,KAAK,CAAL,GAAA,CAAU,UAAA,CAAA,EAAC;AAAA,aAAIC,CAAC,CAAL,CAAK,CAAL;AAAvC,KAA4B,CAA5B,CAAA,CAAA;AAAd,GAAA,EADO,EACP,CAAR,CAAJD,CADmB;AAAvB,CAAA;;AAGO,IAAMG,SAAS,GAAG,SAAZA,SAAY,CAAA,IAAA,EAgBnB;AAAA,MAfFC,KAeE,GAAA,IAAA,CAfFA,KAeE;AAAA,MAdF3D,MAcE,GAAA,IAAA,CAdFA,MAcE;AAAA,MAbFhB,IAaE,GAAA,IAAA,CAbFA,IAaE;AAAA,MAZF+B,IAYE,GAAA,IAAA,CAZFA,IAYE;AAAA,MAXFG,UAWE,GAAA,IAAA,CAXFA,UAWE;AAAA,MAVFF,KAUE,GAAA,IAAA,CAVFA,KAUE;AAAA,MATFI,KASE,GAAA,IAAA,CATFA,KASE;AAAA,MARFQ,MAQE,GAAA,IAAA,CARFA,MAQE;AAAA,MAPFpC,WAOE,GAAA,IAAA,CAPFA,WAOE;AAAA,MANF6C,OAME,GAAA,IAAA,CANFA,OAME;AAAA,MALFC,QAKE,GAAA,IAAA,CALFA,QAKE;AAAA,MAJFC,cAIE,GAAA,IAAA,CAJFA,cAIE;AAAA,MAHFC,cAGE,GAAA,IAAA,CAHFA,cAGE;AAAA,MAFFC,YAEE,GAAA,IAAA,CAFFA,YAEE;AAAA,MADFC,aACE,GAAA,IAAA,CADFA,aACE;AACF,MAAMkB,aAAa,GAAGtD,OAAO,CACzB,YAAA;AAAA,WACI,IAAI,GAAJ,CAAA,CACO,UAAA,KAAA,EAAA;AAAA,UAAGhB,CAAH,GAAA,KAAA,CAAA,CAAA;AAAA,aAAA,CAAA;AADP,KAAA,EAAA,EAAA,CAEQ,UAAA,KAAA,EAAA;AAAA,UAAGuE,EAAH,GAAA,KAAA,CAAA,EAAA;AAAA,aAAA,EAAA;AAFR,KAAA,EAAA,EAAA,CAGQ,UAAA,KAAA,EAAA;AAAA,UAAGC,EAAH,GAAA,KAAA,CAAA,EAAA;AAAA,aAAA,EAAA;AAHR,KAAA,EAAA,KAAA,CAIWC,aAAa,CAL5B,KAK4B,CAJxB,CADJ;AADyB,GAAA,EAOzB,CAPJ,KAOI,CAPyB,CAA7B;AAUA,MAAMC,OAAK,GAAG1D,OAAO,CACjB,YAAA;AAAA,WACI2D,KAAO,GAAPA,IAAAA,CAAAA,IAAAA,EAAAA,MAAAA,CAEYC,mBAAmB,CAF/BD,UAE+B,CAF/BA,EAAAA,KAAAA,CAGWE,kBAAkB,CAJjC,KAIiC,CAH7BF,CADJ;AADiB,GAAA,EAMjB,CAAA,IAAA,EAAA,UAAA,EANJ,KAMI,CANiB,CAArB;;AAXE,MAAA,QAAA,GAoB+B3D,OAAO,CAAC,YAAM;AAC3C,QAAM9B,MAAM,GAAGwF,OAAK,CAApB,IAAoB,CAApB;AACAxF,IAAAA,MAAM,CAANA,OAAAA,CAAe,UAAA,KAAA,EAAS;AACpBxB,MAAAA,KAAK,CAALA,OAAAA,CAAc,UAAA,KAAA,EAAS;AACnBsH,QAAAA,KAAK,CAALA,KAAAA,GAAcA,KAAK,CAALA,IAAAA,CAAWtH,KAAK,CAA9BsH,GAAcA,CAAdA;AADJtH,OAAAA;AADJwB,KAAAA;AAMA,QAAM+F,QAAQ,GAAGjB,QAAQ,CAAzB,MAAyB,CAAzB;AACA,QAAMkB,QAAQ,GAAGf,QAAQ,CAAzB,MAAyB,CAAzB;AAEA,WAAO,CAAA,MAAA,EAEH,UAAU,GAAV,MAAA,CACY,KAAK,CAAL,IAAA,CAAW;AAAEgB,MAAAA,MAAM,EAAEzF,IAAI,CAACyF;AAAf,KAAX,EAAoC,UAAA,CAAA,EAAA,CAAA,EAAA;AAAA,aAAA,CAAA;AADhD,KACY,CADZ,EAAA,KAAA,CAEW,CAAA,CAAA,EAJR,KAIQ,CAFX,CAFG,EAKHC,WAAW,GAAXA,MAAAA,CAAqB,CAAA,QAAA,EAArBA,QAAqB,CAArBA,EAAAA,KAAAA,CAAiD,CAAA,MAAA,EALrD,CAKqD,CAAjDA,CALG,CAAP;AAXoC,GAAA,EAkBrC,CAAA,OAAA,EAAA,IAAA,EAAA,KAAA,EAtCD,MAsCC,CAlBqC,CApBtC;AAAA,MAAA,SAAA,GAAA,cAAA,CAAA,QAAA,EAAA,CAAA,CAAA;AAAA,MAoBKlG,MApBL,GAAA,SAAA,CAAA,CAAA,CAAA;AAAA,MAoBa4F,MApBb,GAAA,SAAA,CAAA,CAAA,CAAA;AAAA,MAoBqBC,MApBrB,GAAA,SAAA,CAAA,CAAA,CAAA;;AAwCF,MAAMM,KAAK,GAAGC,QAAd,EAAA;AACA,MAAMzF,QAAQ,GAAG0F,oBAAoB,CAAA,MAAA,EAArC,OAAqC,CAArC;AACA,MAAM1H,cAAc,GAAG2H,iBAAiB,CAAA,WAAA,EAAxC,KAAwC,CAAxC;AAEA,MAAMC,UAAU,GAAGzE,OAAO,CAAC,YAAA;AAAA,WAAO,OAAA,OAAA,KAAA,UAAA,GAAA,OAAA,GAA0C,YAAA;AAAA,aAAA,OAAA;AAAjD,KAAA;AAAD,GAAA,EAAkE,CAA5F,OAA4F,CAAlE,CAA1B;AAGA,MAAM0E,WAAW,GAAGF,iBAAiB,CAAA,QAAA,EAArC,KAAqC,CAArC;AACA,MAAMG,iBAAiB,GAAG3E,OAAO,CAC7B,YAAA;AAAA,WAAO,OAAA,cAAA,KAAA,UAAA,GAAA,cAAA,GAAwD,YAAA;AAAA,aAAA,cAAA;AAA/D,KAAA;AAD6B,GAAA,EAE7B,CAFJ,cAEI,CAF6B,CAAjC;AAIA,MAAM4E,iBAAiB,GAAGJ,iBAAiB,CAAA,cAAA,EAA3C,KAA2C,CAA3C;AAEA,MAAMK,cAAc,GAAG7E,OAAO,CAC1B,YAAA;AAAA,WACI,MAAM,CAAN,GAAA,CAAW,UAAA,MAAA,EAAA,UAAA,EAAwB;AAC/B,UAAMtD,KAAK,GAAG,MAAM,CAAN,GAAA,CAAW,UAAA,KAAA,EAAA,CAAA,EAAA;AAAA,eAAe;AACpCoI,UAAAA,KAAK,EAD+B,CAAA;AAEpC9F,UAAAA,CAAC,EAAE8E,MAAM,CAF2B,CAE3B,CAF2B;AAGpCiB,UAAAA,KAAK,EAAEf,KAAK,CAHwB,KAAA;AAIpCT,UAAAA,EAAE,EAAEQ,MAAM,CAACC,KAAK,CAJoB,CAIpB,CAAN,CAJ0B;AAKpCR,UAAAA,EAAE,EAAEO,MAAM,CAACC,KAAK,CAAN,CAAM,CAAN;AAL0B,SAAf;AAAzB,OAAc,CAAd;AAQA,aAAO;AACHvF,QAAAA,EAAE,EAAEgC,IAAI,CADL,UACK,CADL;AAEH/D,QAAAA,KAAK,EAFF,KAAA;AAGHsI,QAAAA,IAAI,EAAE1B,aAAa,CAHhB,KAGgB,CAHhB;AAIHjG,QAAAA,KAAK,EAAEwB,QAAQ,CAAC;AAAEiG,UAAAA,KAAK,EAAEG;AAAT,SAAD;AAJZ,OAAP;AAVR,KACI,CADJ;AAD0B,GAAA,EAkB1B,CAAA,MAAA,EAAA,IAAA,EAAA,aAAA,EAlBJ,QAkBI,CAlB0B,CAA9B;AAqBA,MAAM7E,MAAM,GAAGJ,OAAO,CAClB,YAAA;AAAA,WACI,KAAK,CAAL,IAAA,CAAW;AAAEmE,MAAAA,MAAM,EAAEzF,IAAI,CAACyF;AAAf,KAAX,EAAoC,UAAA,CAAA,EAAA,CAAA,EAAU;AAC1C,UAAMe,UAAU,GAAG,cAAc,CAAd,GAAA,CACV,UAAA,KAAA,EAAK;AAAA,eAAA,cAAA,CAAA;AACNzG,UAAAA,EAAE,EAAE/B,KAAK,CADH,EAAA;AAENW,UAAAA,KAAK,EAAEX,KAAK,CAACW;AAFP,SAAA,EAGHX,KAAK,CAALA,KAAAA,CAHG,CAGHA,CAHG,CAAA;AADK,OAAA,EAAA,IAAA,CAMT,UAAA,CAAA,EAAA,CAAA,EAAA;AAAA,eAAUyI,CAAC,CAADA,EAAAA,GAAOC,CAAC,CAAlB,EAAA;AANV,OAAmB,CAAnB;AAQA,aAAO;AACHN,QAAAA,KAAK,EADF,CAAA;AAEH9F,QAAAA,CAAC,EAAE6F,cAAc,CAAdA,CAAc,CAAdA,CAAAA,KAAAA,CAAAA,CAAAA,EAFA,CAAA;AAGHnB,QAAAA,KAAK,EAAEwB;AAHJ,OAAP;AAVR,KACI,CADJ;AADkB,GAAA,EAiBlB,CAACxG,IAAI,CAAL,MAAA,EAjBJ,cAiBI,CAjBkB,CAAtB;AAoBA,MAAM5B,eAAe,GAAGkD,OAAO,CAAC,YAAM;AAClC,QAAI,OAAA,YAAA,KAAJ,UAAA,EAAwC,OAAA,YAAA;AAExC,WAAO,UAAA,CAAA,EAAC;AAAA,aAAIkD,CAAC,CAAL,EAAA;AAAR,KAAA;AAH2B,GAAA,EAI5B,CAJH,YAIG,CAJ4B,CAA/B;AAKA,MAAMvD,eAAe,GAAG0F,iBAAiB,CAAzC,aAAyC,CAAzC;AAEA,SAAO;AACHvB,IAAAA,MAAM,EADH,MAAA;AAEHC,IAAAA,MAAM,EAFH,MAAA;AAGH7F,IAAAA,MAAM,EAHH,cAAA;AAIHkC,IAAAA,MAAM,EAJH,MAAA;AAKHvD,IAAAA,cAAc,EALX,cAAA;AAMH4H,IAAAA,UAAU,EANP,UAAA;AAOHC,IAAAA,WAAW,EAPR,WAAA;AAQHC,IAAAA,iBAAiB,EARd,iBAAA;AASHC,IAAAA,iBAAiB,EATd,iBAAA;AAUH9H,IAAAA,eAAe,EAVZ,eAAA;AAWH6C,IAAAA,eAAe,EAAfA;AAXG,GAAP;AAtHG,CAAA;;ACCP,IAAM2F,MAAM,GAAG,SAATA,MAAS,CAAA,IAAA,EAwCT;AAAA,MAvCF5G,IAuCE,GAAA,IAAA,CAvCFA,IAuCE;AAAA,MAtCF+B,IAsCE,GAAA,IAAA,CAtCFA,IAsCE;AAAA,MArCFG,UAqCE,GAAA,IAAA,CArCFA,UAqCE;AAAA,MApCFF,KAoCE,GAAA,IAAA,CApCFA,KAoCE;AAAA,MAnCFI,KAmCE,GAAA,IAAA,CAnCFA,KAmCE;AAAA,MAjCFuC,KAiCE,GAAA,IAAA,CAjCFA,KAiCE;AAAA,MAhCF3D,MAgCE,GAAA,IAAA,CAhCFA,MAgCE;AAAA,MA/BM8F,aA+BN,GAAA,IAAA,CA/BFD,MA+BE;AAAA,MA7BFvE,OA6BE,GAAA,IAAA,CA7BFA,OA6BE;AAAA,MA5BFC,SA4BE,GAAA,IAAA,CA5BFA,SA4BE;AAAA,MA3BFC,UA2BE,GAAA,IAAA,CA3BFA,UA2BE;AAAA,MA1BFC,QA0BE,GAAA,IAAA,CA1BFA,QA0BE;AAAA,MAzBFC,WAyBE,GAAA,IAAA,CAzBFA,WAyBE;AAAA,MAxBFC,WAwBE,GAAA,IAAA,CAxBFA,WAwBE;AAAA,MAtBFC,MAsBE,GAAA,IAAA,CAtBFA,MAsBE;AAAA,MArBF3E,WAqBE,GAAA,IAAA,CArBFA,WAqBE;AAAA,MApBFC,WAoBE,GAAA,IAAA,CApBFA,WAoBE;AAAA,MAnBFsC,WAmBE,GAAA,IAAA,CAnBFA,WAmBE;AAAA,MAlBFsC,IAkBE,GAAA,IAAA,CAlBFA,IAkBE;AAAA,MAjBFE,IAiBE,GAAA,IAAA,CAjBFA,IAiBE;AAAA,MAfFG,UAeE,GAAA,IAAA,CAfFA,UAeE;AAAA,MAdFC,WAcE,GAAA,IAAA,CAdFA,WAcE;AAAA,MAbFnD,YAaE,GAAA,IAAA,CAbFA,YAaE;AAAA,MAZFoD,OAYE,GAAA,IAAA,CAZFA,OAYE;AAAA,MAXFC,QAWE,GAAA,IAAA,CAXFA,QAWE;AAAA,MAVFC,cAUE,GAAA,IAAA,CAVFA,cAUE;AAAA,MATFC,cASE,GAAA,IAAA,CATFA,cASE;AAAA,MAPFnF,aAOE,GAAA,IAAA,CAPFA,aAOE;AAAA,MANFoF,YAME,GAAA,IAAA,CANFA,YAME;AAAA,MALFC,aAKE,GAAA,IAAA,CALFA,aAKE;AAAA,MAJFC,kBAIE,GAAA,IAAA,CAJFA,kBAIE;AAAA,MAFFC,OAEE,GAAA,IAAA,CAFFA,OAEE;AAAA,MADFC,IACE,GAAA,IAAA,CADFA,IACE;;AAAA,MAAA,cAAA,GACmEsD,aAAa,CAAA,KAAA,EAAA,MAAA,EADhF,aACgF,CADhF;AAAA,MACMN,MADN,GAAA,cAAA,CAAA,MAAA;AAAA,MACcE,UADd,GAAA,cAAA,CAAA,UAAA;AAAA,MAC0BC,WAD1B,GAAA,cAAA,CAAA,WAAA;AAAA,MACuCC,UADvC,GAAA,cAAA,CAAA,UAAA;AAAA,MACmDC,WADnD,GAAA,cAAA,CAAA,WAAA;;AAAA,MAAA,UAAA,GAmBExC,SAAS,CAAC;AACVC,IAAAA,KAAK,EADK,UAAA;AAEV3D,IAAAA,MAAM,EAFI,WAAA;AAGVhB,IAAAA,IAAI,EAHM,IAAA;AAIV+B,IAAAA,IAAI,EAJM,IAAA;AAKVG,IAAAA,UAAU,EALA,UAAA;AAMVF,IAAAA,KAAK,EANK,KAAA;AAOVI,IAAAA,KAAK,EAPK,KAAA;AAQVQ,IAAAA,MAAM,EARI,MAAA;AASVpC,IAAAA,WAAW,EATD,WAAA;AAUV6C,IAAAA,OAAO,EAVG,OAAA;AAWVC,IAAAA,QAAQ,EAXE,QAAA;AAYVC,IAAAA,cAAc,EAZJ,cAAA;AAaVC,IAAAA,cAAc,EAbJ,cAAA;AAcVC,IAAAA,YAAY,EAdF,YAAA;AAeVC,IAAAA,aAAa,EAAbA;AAfU,GAAD,CAnBX;AAAA,MAQE0B,MARF,GAAA,UAAA,CAAA,MAAA;AAAA,MASEC,MATF,GAAA,UAAA,CAAA,MAAA;AAAA,MAUE7F,MAVF,GAAA,UAAA,CAAA,MAAA;AAAA,MAWEkC,MAXF,GAAA,UAAA,CAAA,MAAA;AAAA,MAYEvD,cAZF,GAAA,UAAA,CAAA,cAAA;AAAA,MAaE4H,UAbF,GAAA,UAAA,CAAA,UAAA;AAAA,MAcEC,WAdF,GAAA,UAAA,CAAA,WAAA;AAAA,MAeEC,iBAfF,GAAA,UAAA,CAAA,iBAAA;AAAA,MAgBEC,iBAhBF,GAAA,UAAA,CAAA,iBAAA;AAAA,MAiBE9H,eAjBF,GAAA,UAAA,CAAA,eAAA;AAAA,MAkBE6C,eAlBF,GAAA,UAAA,CAAA,eAAA;;AAqCF,MAAMmG,SAAS,GAAGC,QAAQ,CAAA,IAAA,EAAA,MAAA,EAA1B,IAA0B,CAA1B;AAEA,SACI,KAAA,CAAA,aAAA,CAAA,UAAA,EAAA;AACI,IAAA,KAAK,EADT,UAAA;AAEI,IAAA,MAAM,EAFV,WAAA;AAGI,IAAA,MAAM,EAHV,MAAA;AAII,IAAA,IAAI,EAJR,SAAA;AAKI,IAAA,IAAI,EAAExD;AALV,GAAA,EAOI,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AACI,IAAA,KAAK,EADT,UAAA;AAEI,IAAA,MAAM,EAFV,WAAA;AAGI,IAAA,MAAM,EAAEnB,WAAW,GAAA,MAAA,GAHvB,IAAA;AAII,IAAA,MAAM,EAAEC,WAAW,GAAA,MAAA,GAAY;AAJnC,GAAA,CAPJ,EAaI,KAAA,CAAA,aAAA,CAAA,YAAA,EAAA;AACI,IAAA,MAAM,EADV,MAAA;AAEI,IAAA,WAAW,EAFf,WAAA;AAGI,IAAA,WAAW,EAHf,WAAA;AAII,IAAA,cAAc,EAJlB,cAAA;AAKI,IAAA,eAAe,EALnB,eAAA;AAMI,IAAA,aAAa,EAAEtE;AANnB,GAAA,CAbJ,EAqBI,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AACI,IAAA,MAAM,EADV,MAAA;AAEI,IAAA,MAAM,EAFV,MAAA;AAGI,IAAA,KAAK,EAHT,UAAA;AAII,IAAA,MAAM,EAJV,WAAA;AAKI,IAAA,GAAG,EALP,OAAA;AAMI,IAAA,KAAK,EANT,SAAA;AAOI,IAAA,MAAM,EAPV,UAAA;AAQI,IAAA,IAAI,EAAEoE;AARV,GAAA,CArBJ,EA+BKU,UAAU,IACP,MAAM,CAAN,GAAA,CAAW,UAAA,KAAA,EAAK;AAAA,WACZ,KAAA,CAAA,aAAA,CAAA,YAAA,EAAA;AACI,MAAA,GAAG,EAAEnF,KAAK,CADd,EAAA;AAEI,MAAA,EAAE,EAAEA,KAAK,CAFb,EAAA;AAGI,MAAA,KAAK,EAAEA,KAAK,CAHhB,KAAA;AAII,MAAA,IAAI,EAAEA,KAAK,CAJf,KAAA;AAKI,MAAA,YAAY,EALhB,YAAA;AAMI,MAAA,QAAQ,EANZ,WAAA;AAOI,MAAA,OAAO,EAPX,UAAA;AAQI,MAAA,QAAQ,EARZ,WAAA;AASI,MAAA,cAAc,EATlB,iBAAA;AAUI,MAAA,cAAc,EAAEkI;AAVpB,KAAA,CADY;AAhCxB,GAgCQ,CAhCR,EA8CK7H,aAAa,IAAbA,kBAAAA,IACG,KAAA,CAAA,aAAA,CAAA,cAAA,EAAA;AACI,IAAA,MAAM,EADV,MAAA;AAEI,IAAA,MAAM,EAFV,WAAA;AAGI,IAAA,eAAe,EAHnB,eAAA;AAII,IAAA,eAAe,EAAED;AAJrB,GAAA,CA/CR,EAsDK,OAAO,CAAP,GAAA,CAAY,UAAA,MAAA,EAAA,CAAA,EAAe;AACxB,QAAMkJ,UAAU,GAAG,MAAM,CAAN,GAAA,CACV,UAAA,CAAA,EAAC;AAAA,aAAK;AACPvH,QAAAA,EAAE,EAAEwH,CAAC,CADE,EAAA;AAEPC,QAAAA,KAAK,EAAED,CAAC,CAFD,EAAA;AAGP5I,QAAAA,KAAK,EAAE4I,CAAC,CAHD,KAAA;AAIPvE,QAAAA,IAAI,EAAEuE,CAAC,CAACvE;AAJD,OAAL;AADS,KAAA,EAAnB,OAAmB,EAAnB;AASA,WACI,KAAA,CAAA,aAAA,CAAA,YAAA,EAAA,MAAA,CAAA,MAAA,CAAA;AACI,MAAA,GAAG,EAAEyE;AADT,KAAA,EAAA,MAAA,EAAA;AAGI,MAAA,cAAc,EAHlB,UAAA;AAII,MAAA,eAAe,EAJnB,WAAA;AAKI,MAAA,IAAI,EAAEH;AALV,KAAA,CAAA,CADJ;AAjEZ,GAuDS,CAtDL,CADJ;AA/EJ,CAAA;;IAgKMI,aAAa,GAAGC,aAAa,CAAA,MAAA,C;AACnCD,aAAa,CAAbA,YAAAA,GAAAA,kBAAAA;;ICvKME,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAA,KAAA,EAAK;AAAA,SAC1B,KAAA,CAAA,aAAA,CAAA,iBAAA,EAAA,IAAA,EACK,UAAA,IAAA,EAAA;AAAA,QAAGjD,KAAH,GAAA,IAAA,CAAA,KAAA;AAAA,QAAU3D,MAAV,GAAA,IAAA,CAAA,MAAA;AAAA,WAAuB,KAAA,CAAA,aAAA,CAAA,aAAA,EAAA,MAAA,CAAA,MAAA,CAAA;AAAQ,MAAA,KAAK,EAAb,KAAA;AAAsB,MAAA,MAAM,EAAEA;AAA9B,KAAA,EAAvB,KAAuB,CAAA,CAAvB;AAFqB,GAC1B,CAD0B;AAAA,C","sourcesContent":["/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React, { memo, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { useSpring, animated } from 'react-spring'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { BasicTooltip, useTooltip } from '@nivo/tooltip'\n\nconst StreamLayer = ({\n    layer,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    getTooltipLabel,\n    isInteractive,\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        event => {\n            showTooltipFromEvent(\n                <BasicTooltip id={getTooltipLabel(layer)} enableChip={true} color={layer.color} />,\n                event,\n                'left'\n            )\n        },\n        [showTooltipFromEvent, getTooltipLabel, layer]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(layer.path)\n    const animatedProps = useSpring({\n        color: layer.color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={layer.fill ? layer.fill : animatedProps.color}\n            fillOpacity={fillOpacity}\n            stroke={getBorderColor(layer)}\n            strokeWidth={borderWidth}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? hideTooltip : undefined}\n        />\n    )\n}\n\nStreamLayer.propTypes = {\n    layer: PropTypes.object.isRequired,\n    fillOpacity: PropTypes.number.isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    getBorderColor: PropTypes.func.isRequired,\n    getTooltipLabel: PropTypes.func.isRequired,\n    isInteractive: PropTypes.bool.isRequired,\n}\n\nexport default memo(StreamLayer)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport StreamLayer from './StreamLayer'\n\nconst StreamLayers = ({\n    layers,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    getTooltipLabel,\n    isInteractive,\n}) => {\n    return (\n        <g>\n            {layers.map((layer, i) => (\n                <StreamLayer\n                    key={i}\n                    layer={layer}\n                    getBorderColor={getBorderColor}\n                    borderWidth={borderWidth}\n                    fillOpacity={fillOpacity}\n                    getTooltipLabel={getTooltipLabel}\n                    isInteractive={isInteractive}\n                />\n            ))}\n        </g>\n    )\n}\n\nStreamLayers.propTypes = {\n    layers: PropTypes.array.isRequired,\n    fillOpacity: PropTypes.number.isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    getBorderColor: PropTypes.func.isRequired,\n    getTooltipLabel: PropTypes.func.isRequired,\n    isInteractive: PropTypes.bool.isRequired,\n}\n\nexport default StreamLayers\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React, { memo } from 'react'\nimport PropTypes from 'prop-types'\n\nconst getDotY = (datum, position) => {\n    let y = datum.y2\n    if (position === 'center') {\n        y = datum.y1 + (datum.y2 - datum.y1) / 2\n    } else if (position === 'start') {\n        y = datum.y1\n    }\n\n    return y\n}\n\nconst StreamDots = ({\n    id,\n    color,\n    data,\n    dotComponent,\n    position,\n    getSize,\n    getColor,\n    getBorderWidth,\n    getBorderColor,\n}) => {\n    return data.map((d, i) => {\n        const datum = { ...d, key: id, color }\n\n        return React.createElement(dotComponent, {\n            key: i,\n            datum,\n            x: datum.x,\n            y: getDotY(datum, position),\n            size: getSize(datum),\n            color: getColor(datum),\n            borderWidth: getBorderWidth(datum),\n            borderColor: getBorderColor(datum),\n        })\n    })\n}\n\nStreamDots.propTypes = {\n    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n    color: PropTypes.string.isRequired,\n    data: PropTypes.arrayOf(\n        PropTypes.shape({\n            x: PropTypes.number.isRequired,\n            y1: PropTypes.number.isRequired,\n            y2: PropTypes.number.isRequired,\n        })\n    ).isRequired,\n    dotComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n    position: PropTypes.oneOf(['start', 'center', 'end']).isRequired,\n    getSize: PropTypes.func.isRequired,\n    getColor: PropTypes.func.isRequired,\n    getBorderWidth: PropTypes.func.isRequired,\n    getBorderColor: PropTypes.func.isRequired,\n}\n\nexport default memo(StreamDots)\n","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React, { memo, useCallback, useMemo, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { TableTooltip, Chip } from '@nivo/tooltip'\nimport { useTooltip } from '@nivo/tooltip'\n\nconst StreamSlicesItem = ({ slice, height, getTooltipLabel, getTooltipValue }) => {\n    const [isHover, setIsHover] = useState(false)\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const rows = useMemo(\n        () =>\n            slice.stack.map(p => [\n                <Chip key={p.id} color={p.color} />,\n                getTooltipLabel(p),\n                getTooltipValue(p.value),\n            ]),\n        [slice, getTooltipLabel, getTooltipValue]\n    )\n\n    const handleMouseHover = useCallback(\n        event => {\n            setIsHover(true)\n            showTooltipFromEvent(<TableTooltip rows={rows} />, event, 'left')\n        },\n        [setIsHover, showTooltipFromEvent, rows]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        setIsHover(false)\n        hideTooltip()\n    }, [setIsHover, hideTooltip])\n\n    return (\n        <g transform={`translate(${slice.x}, 0)`}>\n            {isHover && (\n                <line\n                    x1={0}\n                    x2={0}\n                    y1={0}\n                    y2={height}\n                    stroke=\"#000\"\n                    strokeOpacity={0.35}\n                    strokeWidth={1}\n                />\n            )}\n            <rect\n                x={-20}\n                width={40}\n                height={height}\n                fill=\"#000\"\n                fillOpacity={0}\n                onMouseEnter={handleMouseHover}\n                onMouseMove={handleMouseHover}\n                onMouseLeave={handleMouseLeave}\n            />\n        </g>\n    )\n}\n\nStreamSlicesItem.propTypes = {\n    slice: PropTypes.object.isRequired,\n    height: PropTypes.number.isRequired,\n    getTooltipLabel: PropTypes.func.isRequired,\n    getTooltipValue: PropTypes.func.isRequired,\n}\n\nexport default memo(StreamSlicesItem)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React, { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport StreamSlicesItem from './StreamSlicesItem'\n\nconst StreamSlices = ({ slices, height, getTooltipLabel, getTooltipValue }) => (\n    <g>\n        {slices.map(slice => (\n            <StreamSlicesItem\n                key={slice.index}\n                slice={slice}\n                height={height}\n                getTooltipLabel={getTooltipLabel}\n                getTooltipValue={getTooltipValue}\n            />\n        ))}\n    </g>\n)\n\nStreamSlices.propTypes = {\n    slices: PropTypes.arrayOf(\n        PropTypes.shape({\n            index: PropTypes.number.isRequired,\n            x: PropTypes.number.isRequired,\n            stack: PropTypes.arrayOf(\n                PropTypes.shape({\n                    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n                    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n                    color: PropTypes.string.isRequired,\n                })\n            ).isRequired,\n        })\n    ).isRequired,\n    height: PropTypes.number.isRequired,\n    getTooltipLabel: PropTypes.func.isRequired,\n    getTooltipValue: PropTypes.func.isRequired,\n}\n\nexport default memo(StreamSlices)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React, { memo } from 'react'\nimport PropTypes from 'prop-types'\nimport { useSpring, animated } from 'react-spring'\nimport { useMotionConfig } from '@nivo/core'\n\nconst StreamDotsItem = ({ x, y, size, color, borderWidth, borderColor }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size * 0.5,\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.circle\n            cx={animatedProps.x}\n            cy={animatedProps.y}\n            r={animatedProps.radius}\n            fill={animatedProps.color}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n        />\n    )\n}\n\nStreamDotsItem.propTypes = {\n    x: PropTypes.number.isRequired,\n    y: PropTypes.number.isRequired,\n    size: PropTypes.number.isRequired,\n    color: PropTypes.string.isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    borderColor: PropTypes.string.isRequired,\n}\n\nexport default memo(StreamDotsItem)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { areaCurvePropType, stackOrderPropType, stackOffsetPropType } from '@nivo/core'\nimport { ordinalColorsPropType, inheritedColorPropType } from '@nivo/colors'\nimport { LegendPropShape } from '@nivo/legends'\nimport StreamDotsItem from './StreamDotsItem'\n\nexport const StreamPropTypes = {\n    data: PropTypes.arrayOf(PropTypes.object).isRequired,\n    keys: PropTypes.array.isRequired,\n    order: stackOrderPropType.isRequired,\n    offsetType: stackOffsetPropType.isRequired,\n    curve: areaCurvePropType.isRequired,\n\n    axisTop: PropTypes.object,\n    axisRight: PropTypes.object,\n    axisBottom: PropTypes.object,\n    axisLeft: PropTypes.object,\n    enableGridX: PropTypes.bool.isRequired,\n    enableGridY: PropTypes.bool.isRequired,\n\n    colors: ordinalColorsPropType.isRequired,\n    fillOpacity: PropTypes.number.isRequired,\n    defs: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.string.isRequired,\n        })\n    ).isRequired,\n    fill: PropTypes.arrayOf(\n        PropTypes.shape({\n            id: PropTypes.string,\n            match: PropTypes.oneOfType([PropTypes.oneOf(['*']), PropTypes.object, PropTypes.func])\n                .isRequired,\n        })\n    ).isRequired,\n    borderWidth: PropTypes.number.isRequired,\n    borderColor: inheritedColorPropType.isRequired,\n\n    enableDots: PropTypes.bool.isRequired,\n    dotComponent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,\n    dotPosition: PropTypes.oneOf(['start', 'center', 'end']).isRequired,\n    dotSize: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,\n    dotColor: inheritedColorPropType.isRequired,\n    dotBorderWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,\n    dotBorderColor: inheritedColorPropType.isRequired,\n\n    isInteractive: PropTypes.bool,\n    tooltipLabel: PropTypes.func,\n    tooltipFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    enableStackTooltip: PropTypes.bool.isRequired,\n\n    legends: PropTypes.arrayOf(PropTypes.shape(LegendPropShape)).isRequired,\n    role: PropTypes.string.isRequired,\n}\n\nexport const StreamDefaultProps = {\n    order: 'none',\n    offsetType: 'wiggle',\n    curve: 'catmullRom',\n\n    axisBottom: {},\n    enableGridX: true,\n    enableGridY: false,\n\n    borderWidth: 0,\n    borderColor: { from: 'color', modifiers: [['darker', 1]] },\n\n    colors: { scheme: 'nivo' },\n    fillOpacity: 1,\n    defs: [],\n    fill: [],\n\n    enableDots: false,\n    dotPosition: 'center',\n    dotComponent: StreamDotsItem,\n    dotSize: 6,\n    dotColor: { from: 'color' },\n    dotBorderWidth: 0,\n    dotBorderColor: { from: 'color' },\n\n    isInteractive: true,\n\n    enableStackTooltip: true,\n\n    legends: [],\n    role: 'img',\n\n    animate: true,\n    motionConfig: 'gentle',\n}\n","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import { useMemo } from 'react'\nimport { area, stack as d3Stack } from 'd3-shape'\nimport { scaleLinear, scalePoint } from 'd3-scale'\nimport {\n    curveFromProp,\n    useTheme,\n    stackOrderFromProp,\n    stackOffsetFromProp,\n    useValueFormatter,\n} from '@nivo/core'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\n\nconst stackMin = layers =>\n    Math.min(...layers.reduce((acc, layer) => [...acc, ...layer.map(d => d[0])], []))\nconst stackMax = layers =>\n    Math.max(...layers.reduce((acc, layer) => [...acc, ...layer.map(d => d[1])], []))\n\nexport const useStream = ({\n    width,\n    height,\n    data,\n    keys,\n    offsetType,\n    order,\n    curve,\n    colors,\n    borderColor,\n    dotSize,\n    dotColor,\n    dotBorderWidth,\n    dotBorderColor,\n    tooltipLabel,\n    tooltipFormat,\n}) => {\n    const areaGenerator = useMemo(\n        () =>\n            area()\n                .x(({ x }) => x)\n                .y0(({ y1 }) => y1)\n                .y1(({ y2 }) => y2)\n                .curve(curveFromProp(curve)),\n        [curve]\n    )\n\n    const stack = useMemo(\n        () =>\n            d3Stack()\n                .keys(keys)\n                .offset(stackOffsetFromProp(offsetType))\n                .order(stackOrderFromProp(order)),\n        [keys, offsetType, order]\n    )\n\n    const [layers, xScale, yScale] = useMemo(() => {\n        const layers = stack(data)\n        layers.forEach(layer => {\n            layer.forEach(point => {\n                point.value = point.data[layer.key]\n            })\n        })\n\n        const minValue = stackMin(layers)\n        const maxValue = stackMax(layers)\n\n        return [\n            layers,\n            scalePoint()\n                .domain(Array.from({ length: data.length }, (_, i) => i))\n                .range([0, width]),\n            scaleLinear().domain([minValue, maxValue]).range([height, 0]),\n        ]\n    }, [stack, data, width, height])\n\n    const theme = useTheme()\n    const getColor = useOrdinalColorScale(colors, 'index')\n    const getBorderColor = useInheritedColor(borderColor, theme)\n\n    const getDotSize = useMemo(() => (typeof dotSize === 'function' ? dotSize : () => dotSize), [\n        dotSize,\n    ])\n    const getDotColor = useInheritedColor(dotColor, theme)\n    const getDotBorderWidth = useMemo(\n        () => (typeof dotBorderWidth === 'function' ? dotBorderWidth : () => dotBorderWidth),\n        [dotBorderWidth]\n    )\n    const getDotBorderColor = useInheritedColor(dotBorderColor, theme)\n\n    const enhancedLayers = useMemo(\n        () =>\n            layers.map((points, layerIndex) => {\n                const layer = points.map((point, i) => ({\n                    index: i,\n                    x: xScale(i),\n                    value: point.value,\n                    y1: yScale(point[0]),\n                    y2: yScale(point[1]),\n                }))\n\n                return {\n                    id: keys[layerIndex],\n                    layer,\n                    path: areaGenerator(layer),\n                    color: getColor({ index: layerIndex }),\n                }\n            }),\n        [layers, keys, areaGenerator, getColor]\n    )\n\n    const slices = useMemo(\n        () =>\n            Array.from({ length: data.length }, (_, i) => {\n                const sliceStack = enhancedLayers\n                    .map(layer => ({\n                        id: layer.id,\n                        color: layer.color,\n                        ...layer.layer[i],\n                    }))\n                    .sort((a, b) => a.y2 - b.y2)\n\n                return {\n                    index: i,\n                    x: enhancedLayers[0].layer[i].x,\n                    stack: sliceStack,\n                }\n            }),\n        [data.length, enhancedLayers]\n    )\n\n    const getTooltipLabel = useMemo(() => {\n        if (typeof tooltipLabel === 'function') return tooltipLabel\n\n        return d => d.id\n    }, [tooltipLabel])\n    const getTooltipValue = useValueFormatter(tooltipFormat)\n\n    return {\n        xScale,\n        yScale,\n        layers: enhancedLayers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        getTooltipLabel,\n        getTooltipValue,\n    }\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React from 'react'\nimport { bindDefs, SvgWrapper, useDimensions, withContainer } from '@nivo/core'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport StreamLayers from './StreamLayers'\nimport StreamDots from './StreamDots'\nimport StreamSlices from './StreamSlices'\nimport { StreamPropTypes, StreamDefaultProps } from './props'\nimport { useStream } from './hooks'\n\nconst Stream = ({\n    data,\n    keys,\n    offsetType,\n    order,\n    curve,\n\n    width,\n    height,\n    margin: partialMargin,\n\n    axisTop,\n    axisRight,\n    axisBottom,\n    axisLeft,\n    enableGridX,\n    enableGridY,\n\n    colors,\n    fillOpacity,\n    borderWidth,\n    borderColor,\n    defs,\n    fill,\n\n    enableDots,\n    dotPosition,\n    dotComponent,\n    dotSize,\n    dotColor,\n    dotBorderWidth,\n    dotBorderColor,\n\n    isInteractive,\n    tooltipLabel,\n    tooltipFormat,\n    enableStackTooltip,\n\n    legends,\n    role,\n}) => {\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        xScale,\n        yScale,\n        layers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        getTooltipLabel,\n        getTooltipValue,\n    } = useStream({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        keys,\n        offsetType,\n        order,\n        curve,\n        colors,\n        borderColor,\n        dotSize,\n        dotColor,\n        dotBorderWidth,\n        dotBorderColor,\n        tooltipLabel,\n        tooltipFormat,\n    })\n\n    const boundDefs = bindDefs(defs, layers, fill)\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n        >\n            <Grid\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n            />\n            <StreamLayers\n                layers={layers}\n                fillOpacity={fillOpacity}\n                borderWidth={borderWidth}\n                getBorderColor={getBorderColor}\n                getTooltipLabel={getTooltipLabel}\n                isInteractive={isInteractive}\n            />\n            <Axes\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n            {enableDots &&\n                layers.map(layer => (\n                    <StreamDots\n                        key={layer.id}\n                        id={layer.id}\n                        color={layer.color}\n                        data={layer.layer}\n                        dotComponent={dotComponent}\n                        position={dotPosition}\n                        getSize={getDotSize}\n                        getColor={getDotColor}\n                        getBorderWidth={getDotBorderWidth}\n                        getBorderColor={getDotBorderColor}\n                    />\n                ))}\n            {isInteractive && enableStackTooltip && (\n                <StreamSlices\n                    slices={slices}\n                    height={innerHeight}\n                    getTooltipValue={getTooltipValue}\n                    getTooltipLabel={getTooltipLabel}\n                />\n            )}\n            {legends.map((legend, i) => {\n                const legendData = layers\n                    .map(l => ({\n                        id: l.id,\n                        label: l.id,\n                        color: l.color,\n                        fill: l.fill,\n                    }))\n                    .reverse()\n\n                return (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legendData}\n                    />\n                )\n            })}\n        </SvgWrapper>\n    )\n}\n\nStream.propTypes = StreamPropTypes\n\nconst WrappedStream = withContainer(Stream)\nWrappedStream.defaultProps = StreamDefaultProps\n\nexport default WrappedStream\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphal Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport Stream from './Stream'\n\nconst ResponsiveStream = props => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Stream width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n\nexport default ResponsiveStream\n"]},"metadata":{},"sourceType":"module"}