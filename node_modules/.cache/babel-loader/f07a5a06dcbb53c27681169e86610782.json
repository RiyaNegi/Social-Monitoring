{"ast":null,"code":"// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// Usage:\n//\n// var xor4096 = require('xor4096');\n// random = xor4096(1);                        // Seed with int32 or string.\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n(function (global, module, define) {\n  function XorGen(seed) {\n    var me = this; // Set up generator function.\n\n    me.next = function () {\n      var w = me.w,\n          X = me.X,\n          i = me.i,\n          t,\n          v; // Update Weyl generator.\n\n      me.w = w = w + 0x61c88647 | 0; // Update xor generator.\n\n      v = X[i + 34 & 127];\n      t = X[i = i + 1 & 127];\n      v ^= v << 13;\n      t ^= t << 17;\n      v ^= v >>> 15;\n      t ^= t >>> 12; // Update Xor generator array state.\n\n      v = X[i] = v ^ t;\n      me.i = i; // Result is the combination.\n\n      return v + (w ^ w >>> 16) | 0;\n    };\n\n    function init(me, seed) {\n      var t,\n          v,\n          i,\n          j,\n          w,\n          X = [],\n          limit = 128;\n\n      if (seed === (seed | 0)) {\n        // Numeric seeds initialize v, which is used to generates X.\n        v = seed;\n        seed = null;\n      } else {\n        // String seeds are mixed into v and X one character at a time.\n        seed = seed + '\\0';\n        v = 0;\n        limit = Math.max(limit, seed.length);\n      } // Initialize circular array and weyl value.\n\n\n      for (i = 0, j = -32; j < limit; ++j) {\n        // Put the unicode characters into the array, and shuffle them.\n        if (seed) v ^= seed.charCodeAt((j + 32) % seed.length); // After 32 shuffles, take v as the starting w value.\n\n        if (j === 0) w = v;\n        v ^= v << 10;\n        v ^= v >>> 15;\n        v ^= v << 4;\n        v ^= v >>> 13;\n\n        if (j >= 0) {\n          w = w + 0x61c88647 | 0; // Weyl.\n\n          t = X[j & 127] ^= v + w; // Combine xor and weyl to init array.\n\n          i = 0 == t ? i + 1 : 0; // Count zeroes.\n        }\n      } // We have detected all zeroes; make the key nonzero.\n\n\n      if (i >= 128) {\n        X[(seed && seed.length || 0) & 127] = -1;\n      } // Run the generator 512 times to further mix the state before using it.\n      // Factoring this as a function slows the main generator, so it is just\n      // unrolled here.  The weyl generator is not advanced while warming up.\n\n\n      i = 127;\n\n      for (j = 4 * 128; j > 0; --j) {\n        v = X[i + 34 & 127];\n        t = X[i = i + 1 & 127];\n        v ^= v << 13;\n        t ^= t << 17;\n        v ^= v >>> 15;\n        t ^= t >>> 12;\n        X[i] = v ^ t;\n      } // Storing state as object members is faster than using closure variables.\n\n\n      me.w = w;\n      me.X = X;\n      me.i = i;\n    }\n\n    init(me, seed);\n  }\n\n  function copy(f, t) {\n    t.i = f.i;\n    t.w = f.w;\n    t.X = f.X.slice();\n    return t;\n  }\n\n  ;\n\n  function impl(seed, opts) {\n    if (seed == null) seed = +new Date();\n\n    var xg = new XorGen(seed),\n        state = opts && opts.state,\n        prng = function () {\n      return (xg.next() >>> 0) / 0x100000000;\n    };\n\n    prng.double = function () {\n      do {\n        var top = xg.next() >>> 11,\n            bot = (xg.next() >>> 0) / 0x100000000,\n            result = (top + bot) / (1 << 21);\n      } while (result === 0);\n\n      return result;\n    };\n\n    prng.int32 = xg.next;\n    prng.quick = prng;\n\n    if (state) {\n      if (state.X) copy(state, xg);\n\n      prng.state = function () {\n        return copy(xg, {});\n      };\n    }\n\n    return prng;\n  }\n\n  if (module && module.exports) {\n    module.exports = impl;\n  } else if (define && define.amd) {\n    define(function () {\n      return impl;\n    });\n  } else {\n    this.xor4096 = impl;\n  }\n})(this, // window object or global\ntypeof module == 'object' && module, // present in node.js\ntypeof define == 'function' && define // present with an AMD loader\n);","map":{"version":3,"sources":["/home/riya/social-monitoring/node_modules/seedrandom/lib/xor4096.js"],"names":["global","module","define","XorGen","seed","me","next","w","X","i","t","v","init","j","limit","Math","max","length","charCodeAt","copy","f","slice","impl","opts","Date","xg","state","prng","double","top","bot","result","int32","quick","exports","amd","xor4096"],"mappings":"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","sourcesContent":["// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// Usage:\n//\n// var xor4096 = require('xor4096');\n// random = xor4096(1);                        // Seed with int32 or string.\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n\n(function(global, module, define) {\n\nfunction XorGen(seed) {\n  var me = this;\n\n  // Set up generator function.\n  me.next = function() {\n    var w = me.w,\n        X = me.X, i = me.i, t, v;\n    // Update Weyl generator.\n    me.w = w = (w + 0x61c88647) | 0;\n    // Update xor generator.\n    v = X[(i + 34) & 127];\n    t = X[i = ((i + 1) & 127)];\n    v ^= v << 13;\n    t ^= t << 17;\n    v ^= v >>> 15;\n    t ^= t >>> 12;\n    // Update Xor generator array state.\n    v = X[i] = v ^ t;\n    me.i = i;\n    // Result is the combination.\n    return (v + (w ^ (w >>> 16))) | 0;\n  };\n\n  function init(me, seed) {\n    var t, v, i, j, w, X = [], limit = 128;\n    if (seed === (seed | 0)) {\n      // Numeric seeds initialize v, which is used to generates X.\n      v = seed;\n      seed = null;\n    } else {\n      // String seeds are mixed into v and X one character at a time.\n      seed = seed + '\\0';\n      v = 0;\n      limit = Math.max(limit, seed.length);\n    }\n    // Initialize circular array and weyl value.\n    for (i = 0, j = -32; j < limit; ++j) {\n      // Put the unicode characters into the array, and shuffle them.\n      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n      // After 32 shuffles, take v as the starting w value.\n      if (j === 0) w = v;\n      v ^= v << 10;\n      v ^= v >>> 15;\n      v ^= v << 4;\n      v ^= v >>> 13;\n      if (j >= 0) {\n        w = (w + 0x61c88647) | 0;     // Weyl.\n        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.\n        i = (0 == t) ? i + 1 : 0;     // Count zeroes.\n      }\n    }\n    // We have detected all zeroes; make the key nonzero.\n    if (i >= 128) {\n      X[(seed && seed.length || 0) & 127] = -1;\n    }\n    // Run the generator 512 times to further mix the state before using it.\n    // Factoring this as a function slows the main generator, so it is just\n    // unrolled here.  The weyl generator is not advanced while warming up.\n    i = 127;\n    for (j = 4 * 128; j > 0; --j) {\n      v = X[(i + 34) & 127];\n      t = X[i = ((i + 1) & 127)];\n      v ^= v << 13;\n      t ^= t << 17;\n      v ^= v >>> 15;\n      t ^= t >>> 12;\n      X[i] = v ^ t;\n    }\n    // Storing state as object members is faster than using closure variables.\n    me.w = w;\n    me.X = X;\n    me.i = i;\n  }\n\n  init(me, seed);\n}\n\nfunction copy(f, t) {\n  t.i = f.i;\n  t.w = f.w;\n  t.X = f.X.slice();\n  return t;\n};\n\nfunction impl(seed, opts) {\n  if (seed == null) seed = +(new Date);\n  var xg = new XorGen(seed),\n      state = opts && opts.state,\n      prng = function() { return (xg.next() >>> 0) / 0x100000000; };\n  prng.double = function() {\n    do {\n      var top = xg.next() >>> 11,\n          bot = (xg.next() >>> 0) / 0x100000000,\n          result = (top + bot) / (1 << 21);\n    } while (result === 0);\n    return result;\n  };\n  prng.int32 = xg.next;\n  prng.quick = prng;\n  if (state) {\n    if (state.X) copy(state, xg);\n    prng.state = function() { return copy(xg, {}); }\n  }\n  return prng;\n}\n\nif (module && module.exports) {\n  module.exports = impl;\n} else if (define && define.amd) {\n  define(function() { return impl; });\n} else {\n  this.xor4096 = impl;\n}\n\n})(\n  this,                                     // window object or global\n  (typeof module) == 'object' && module,    // present in node.js\n  (typeof define) == 'function' && define   // present with an AMD loader\n);\n"]},"metadata":{},"sourceType":"script"}